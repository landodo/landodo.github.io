<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">


<meta name="robots" content="index, follow">
<title>《STL 源码剖析》STL 学习笔记 | Landodo&#39;s NoteBook</title>
<meta name="keywords" content="C&#43;&#43;, STL" />
<meta name="description" content="这是我学习 STL 的笔记。 更新日志 2019-03-04 新增了[STL 概述与版本简介](#STL 概述与版本简介)、空间分配器（allocators）、迭代器（iter">
<meta name="author" content="">
<link rel="canonical" href="http://landodo.github.io/posts/20190304-stl-notes/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://landodo.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://landodo.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://landodo.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://landodo.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="http://landodo.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="《STL 源码剖析》STL 学习笔记" />
<meta property="og:description" content="这是我学习 STL 的笔记。 更新日志 2019-03-04 新增了[STL 概述与版本简介](#STL 概述与版本简介)、空间分配器（allocators）、迭代器（iter" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://landodo.github.io/posts/20190304-stl-notes/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-04T17:22:19&#43;08:00" />
<meta property="article:modified_time" content="2019-03-04T17:22:19&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="《STL 源码剖析》STL 学习笔记"/>
<meta name="twitter:description" content="这是我学习 STL 的笔记。 更新日志 2019-03-04 新增了[STL 概述与版本简介](#STL 概述与版本简介)、空间分配器（allocators）、迭代器（iter"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://landodo.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "《STL 源码剖析》STL 学习笔记",
      "item": "http://landodo.github.io/posts/20190304-stl-notes/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "《STL 源码剖析》STL 学习笔记",
  "name": "《STL 源码剖析》STL 学习笔记",
  "description": "这是我学习 STL 的笔记。 更新日志 2019-03-04 新增了[STL 概述与版本简介](#STL 概述与版本简介)、空间分配器（allocators）、迭代器（iter",
  "keywords": [
    "C++", "STL"
  ],
  "articleBody": "这是我学习 STL 的笔记。\n更新日志\n 2019-03-04  新增了[STL 概述与版本简介](#STL 概述与版本简介)、空间分配器（allocators）、迭代器（iterators）、序列式容器-vector\n 2019-03-05  增加了list\n 2019-03-06  增加了 deque、heap、priority_queue、slist\n STL源码剖析 SGI STL 版本源码的可读性极佳，运用也最为广泛，是 GNU C++ 的标准链接库，并且开放自由。\n日常编程广泛运用的各种数据结构（data structures）和算法（algorithms）在 STL 中有良好的实现，连内存配置与管理也都重重考虑了最佳效能。\nSTL 源码中有着 vector、list、heap、deque、RB-tree、hash-table、set/map，以及各种算法（排序、搜索、排列组合……）的底层实现。\n从技术研究与本质提升的角度看，探究 STL 的细节可以帮助彻底的掌握一切，获得深厚扎实的基础。\nSGI STL 称得上是一个一流作品，追踪一流作品并且吸取养分，远比自己关起门来写个三流作品，价值高得多。\nSTL概述与版本简介 为了建立数据结构和算法的一套标准，并且降低其间的耦合（coupling）关系以提升各自的独立性、弹性、交互操作性（相互合作性，interoperability），STL 诞生了。\nSTL 带来了一个高层次的、以泛型思维（Generic Paradigm）为基础的、系统化的、条理分明的「软件组件分类学（components taxonomy）」。\nSTL的历史 STL 的创始人：Alexander Stepanov。\nAlexander Stepanov 分别􏰄实验了多种架构和算法公式，先以 C 完成，而后再以 C++ 完成。1993 年 11 月完成正式提案，STL 成为 C++ 标准规格的一部分。\nSTL与C++标准链接库 Alexander 向 C++ 标准委员提交提案后，STL 在会议中取得了压倒性的胜利。STL 进入了 C++ 标准化的正式流程，C++ 链接库如 stream, string 等也都以template 重新写过 。\nSTL六大组件  容器（containers）  各种数据结构，如 vector, list, deque, set, map。可以理解为包含对象的类。\n算法（algorithms）  各种常用算法如 sort, search, copy, erase。适用于不同类型容器的函数。\n迭代器（iterators）  容器中的“指针”。\n仿函式（functors）  STL 包括重载函数调用操作符的类。类的实例称为函数对象或仿函数。函数允许在传递参数的帮助下自定义相关函数的工作。\n适配器（adapters）  修饰容器（containers）或仿函式（functors）或迭代器（iterators）。\n分配器（allocators）  负责空间分配与管理，即用于分配空间的对象。\nC++规范 使用无拓展名的头文件。\n#include GNU源码开放精神 STL 源码属于 HP 公司拥有，每一个头文件重都有声明。开放源码的精神，一般统称为 open source。\nStallman 于 1984 创立自由软件基金会（Free Software Foundation），简称FSF。\nHP版本 每一个 HP STL 头文件都有如下一份声明。\n * Copyright (c) 1994\r* Hewlett-Packard Company SGI-STL版本 SGI 版􏰁由 Silicon Graphics Computer Systems, Inc. 公司发展，承继 HP 版􏰁。它的每一个头文件也都有 HP 的版􏰁本声明。\n * Copyright (c) 1996\r* Silicon Graphics Computer Systems, Inc. 在我的设备上，STL 源码位于以下目录：\n/usr/include/c++/4.2.1 每一份 STL 源码都包含三个版权声明，如下：\n// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.   * Copyright (c) 1994  * Hewlett-Packard Company   * Copyright (c) 1996  * Silicon Graphics Computer Systems, Inc.   /** @file include/vector * This is a Standard C++ Library header. */ 空间分配器（allocators） 整个 STL 的操作对象（所有的数值）都存放在容器之内，而容器一定需要分配空间以置放数据。\narray_allocator.h\rbitmap_allocator.h\rdebug_allocator.h\t# 可以包装任意其它的allocato\rmalloc_allocator.h\t# 包装malloc和free\rmt_allocator.h\rnew_allocator.h # 默认使用的allocator\rpool_allocator.h\t# 唯一一个带内存池的allocator\rthrow_allocator.h 分配器的标准接口 打开 new_allocator.h，可以看到 allocator 所提供的接口。\n设计分配器 src/my_allocator.h  src/test_my_allocator.cc 二级分配（sub-allocation）的SGI空间分配器 vector iv; SGI标准的空间分配器std::allocator SGI 定义有一个符合部分标准、名为 allocator 的分配器，但是效率不高，只把 C++ 的 ::operator new 和 ::operator delete 做一层封装而已。\nSGI特殊的空间分配器std::alloc STL allocator 将内存申请由 alloc:allocate() 负责，内存释放由 alloc::deallocate() 负责，对象构造由::construct() 负责，对象销毁由 ::destroy() 负责。\n配置器定义于  文件中，  中包含：\n#include \t// 负责内存空间的配置与释放#include \t// 负责对象的构建与销毁对象的构造和销毁：construct()和destroy() stl_construct.h 中包含以下函数：\n_Construct() 接受一个指针 p 和一个初值 value，此函式的用途就是将初值设定到指针所指的空间上。\n// 销毁将指针所指东西 _Destroy(_Tp* __pointer)  // 销毁[first, last]之间的东西 _Destroy(_ForwardIterator __first, _ForwardIterator __last) 空间的申请与释放std::alloc 空间的申请、释放由  负责。\nSGI 设计了双层级分配器，第一级分配器直接使用 malloc() 和 free()，第二级分配器则视情况采用不同的策略：当分配空间超过 128bytes，便呼叫第一级分配器；当分配空间小于 128bytes，为了降低额外负担，便采用复杂的 memory pool 整理方式，而不再求助于第一级分配器。\n第一级分配器 第一级分配器直接使用 malloc()，SGI 以 malloc 而非 ::operator new 来分配内存。\n第二级分配器 第二级分配器多了一些机制，避免􏰃多小额区块造成内存的碎片。当区块小于 128 bytes，则以 memory pool 管理，此法又称为二级分配（sub-allocation）：每次配置一大块内存，并维护对应之自由表（free-list）。下次若再有相同大小的内存需求，就直接从 free-lists 中分出。\n// pool_allocator.h union _Obj {  union _Obj* _M_free_list_link;  char _M_client_data[1]; // The client sees this. }; 控件分配函数allocate() 此函数首先判断区块大小，大于 128 bytes 就调用第一级分配器，小于 128 bytes 就检查对应的 free list。如果 free list 中有可用的区块，就直接拿来用，如果没有可用区块，就将区块大小上调至 8 倍数边界，然后呼叫refill()，准备为 free list 重新填充空间。\n控件释放函数deallocate() 此函数首先判断区块大小，大于 128 bytes 就调用第一级分配器，小于 128 bytes 就找出对应的 free list，将区块回收。\n重新填充free list free list 中没有可用区块了，就呼叫 refill() 为 free list 重新填充空间。\n内存池（memory pool） 判断内存池的剩余容量，然后将空间分配给 free list。\n// 判断内存池的剩余容量 end_free - start_free 内存基本处理工具 STL 定义有五个函数，作用于􏰅初始化空间上。\n前两个是 construct() 和 destroy()，另外三个函数位于  中。\nuninitialized_copy()\n将内存的分配与对象的构造行为分离开来。\n它接收 3 个参数：\n 迭代器 first 指向输入端的起始位置 迭代器 last 指向输入端的结束位置 迭代器 result 指向输出端（欲初始化空间）的起始处  uninitialized_fill()\n将内存的分配与对象的构造行为分离开来，它要不就产生出所有必要元素，要不就不产生任何元素。\n它接收 3 个参数：\n 迭代器 first 指向输出端（欲初始化空间）的起始处 迭代器 last 指向输出端（欲初始化空间）的结束处 x 表示初值  uninitialized_fill_n()\n将内存的分配与对象的构造行为分离开来，它会为指定范围内的所有元素设定相同的初值。\n它接收 3 个参数：\n first：指向欲初始化空间的起始处 n：表示欲初始化空间的大小 x：初值  迭代器（iterators） iterator：提供一种方法，是的得可以按顺序访问某个聚合物（容器）所􏰈的各个元素，而又不会暴露该聚合物（容器）的内部实现。\n迭代器的设计思维——STL的关键 STL 的中心思想在于，将数据容器（containers）和算法（algorithms）分开，彼此独立设计，最后再以一种粘合剂将它们联系在一起。迭代器（iterators）就是联系容器（containers）和算法（algorithms）的粘合剂。\n迭代器是一种smart-pointer 迭代器是一种行为类似指针的对象，而指针的各种行为中最常见也最重要的便是内容提领（dereference）和成员取用（member access）。迭代器最重要的编程工作就是对 operator* 和 operator- 进行重载（overloading）工程。\nauto_ptr 的源码在头文件  中。\n// memory templatetypename _Tp class auto_ptr { private:  _Tp* _M_ptr;  public: //.... } 每一种 STL 容器都提供有专属迭代器，目的就是为了封装细节不被使用者所看到。\n迭代器相应类型 算法之中运用迭代器时，很可能会用到其相应类型􏰄（associated type）。\n可以使用利用 function template 的自变量推导（argument deducation）机制。\nTraits编程技巧 src/my_iter.cc func() 的回返型􏰄必须加上关键词 typename，关键词 typename 的用意在告诉编译器说这是一个类型􏰄。\nPartial Specialization（偏特化）的意义 templatetypename T class CT* { ... }; template typename T struct iterator_traitsconst T* {  // 当迭代器是个pointer-to-const  // 萃取出来的类型应该是 T 而非 const T  typedef value_type; };  template typename I typename iterator_traitsI::value_type func(I ite) {  return *ite; } 根据经验，最常用到的迭代器相应型􏰄有五种：value type, difference type, pointer, reference,iterator catagoly。\n// stl_iterator.h typename iterator_traits_Iterator::iterator_category, typename iterator_traits_Iterator::value_type, typename iterator_traits_Iterator::difference_type, typename iterator_traits_Iterator::pointer, typename iterator_traits_Iterator::reference value_type\n指迭代器所指对象的类型。\ndifference_type\n表示两个迭代器之间的距离。因此，它可以用来表示一个容器的最大容量，因为对于连续空间的容器而言，头尾之间的距离就是其最大容量。\nreference\nC++ 的函数如果要传回左值，都是以 by reference 的方式进行。\npointer\n能够传回一个 pointer，指向迭代器所指之物。\nItem\u0026 operator*() const { return *ptr; } Item* operator-() const { return ptr; } Item\u0026 便是 reference type ， Item* 是 pointer type。\niterator_category\n迭代器的分类：\n Input Iterator：这种迭代器所指对象，不允许外界改变 Output Iterator：只能写（write only） Forward Iterator：读写动作 Bidirectional Iterator：可双向移动 Random Access Iterator：涵盖所有算术能力  iterator 源码 iterator\rstl_iterator.h\rstl_iterator_base_funcs.h\rstl_iterator_base_types.h\rstl_raw_storage_iter.h\rstream_iterator.h\rstreambuf_iterator.h 序列式容器（sequence containers） 容器是大多数人对 STL 的第一印象。\n序列式容器，其中的元素都可序（ordered），但􏰅未排序（sorted）。C++ 语言本􏰁身提供了一个序列式容器 array，STL 另外再提供 vector, list, deque, stack, queue, priority-queue 等等序列式容器。其中 stack 和 queue 由是将 deque 改头换面而成，技术上被归类为一种适配器（adapter）。\nvector vector 的数据安排以及操作方式，与 array 非常像似。它们之间的差别在于：\n  array 是静态空间，扩容和缩容操作首先配置一块新空间，然后将元素从旧空间一一搬往新空间，然后再把原来的空间释还给系统。\n  vector 是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。\n  // stl_vector.h vector的迭代器 typedef __gnu_cxx::__normal_iteratorpointer, vector_type iterator; typedef __gnu_cxx::__normal_iteratorconst_pointer, vector_type const_iterator; typedef std::reverse_iteratorconst_iterator const_reverse_iterator; typedef std::reverse_iteratoriterator\treverse_iterator; vector 支持随机存取，提供的是 Random Access Iterators。\nvector的数据结构 vector 所采用的数据结构非常简单：线性连续空间。\nstruct _Vector_impl : public _Tp_alloc_type { \t_Tp* _M_start;\t// 表示目前使用空间的头 \t_Tp* _M_finish;\t// 表示目前使用空间的尾 \t_Tp* _M_end_of_storage;\t// 表示目前可用空间的尾 }; vector 实际配置的大小可能比客端需求量更大一些，以备将来可能的扩充。\nsize 表示元素的个数，capacity 表示 vector 的容量。当增加新元素时，size 增加，当 size 超过容量（capacity）的时候，vector 的容量会增加两倍。如果两倍容量仍不足，就扩张至足够大的容量。\n例如下面的例子：\n#include #include  using std::vector;  int main() {  vectorint vec;  for (int i = 0; i  10; ++i) {  vec.push_back(i);  printf(\"capacity=%d, size=%d\\n\", vec.capacity(), vec.size());  }  return 0; } // 运行结果 capacity=1, size=1 capacity=2, size=2 capacity=4, size=3 capacity=4, size=4 capacity=8, size=5 capacity=8, size=6 capacity=8, size=7 capacity=8, size=8 capacity=16, size=9 capacity=16, size=10 vector的构造与内存管理constructor,push_back vector 提供许多 constructors，其中一个允许我们指定空间大小及初值:\nvector(size_type n, const T\u0026 value) {  fill_initialize(n, value); } 当我们以 push_back() 将新元素安插于 vector 尾端，该函式首先检查是否还有备用空间？如果有就直接在备用空间上建构元素，并调整迭代器 finish，使 vector 变大。如果没有备用空间了，就扩充空间（重新分配、搬移数据、释放原空间）。\n// stl_bvector.h void _M_insert_aux(iterator __position, bool __x) { \t// 检查是否还有备用空间  if (this-_M_impl._M_finish._M_p != this-_M_impl._M_end_of_storage) \t{  // 构造一个新元素 \tstd::copy_backward(__position, this-_M_impl._M_finish, \tthis-_M_impl._M_finish + 1); \t*__position = __x;  // 调整 finish \t++this-_M_impl._M_finish; \t} \telse \t{  // 如果原大小不为 0，则配置原大小的两倍 \tconst size_type __len = size() ? 2 * size() \t: static_castsize_type(_S_word_bit); \t_Bit_type * __q = this-_M_allocate(__len); \titerator __i = _M_copy_aligned(begin(), __position, \titerator(__q, 0)); \t*__i++ = __x; \tthis-_M_impl._M_finish = std::copy(__position, end(), __i); \tthis-_M_deallocate(); \tthis-_M_impl._M_end_of_storage = (__q + ((__len \t+ int(_S_word_bit) - 1) \t/ int(_S_word_bit))); \tthis-_M_impl._M_start = iterator(__q, 0); \t} } 所谓动态增加大小，并不是在原空间之后接续新空间（因为无法保证原空间之后尚有可供插入的空间），而是以原大小的两倍另外分配一块空间，然后将原内容拷贝过来，然后才开始在原内容之后插入新元素，并释放原空间。\nvector的元素操作pop_back,erase,clear,insert pop_back\n// stl_bvector.h  // 将尾部元素拿掉，并调整大小(finish减小) void pop_back() { \t--this-_M_impl._M_finish; }   size_type size() const {  return size_type(end() - begin()); }  iterator end() {  return this-_M_impl._M_finish; } erase\n// stl_bvector.h  // 清除[first, finish]中的所有元素 // 使用后面的元素覆盖要删除的区间，然后修改 finish 指针 iterator erase(iterator __first, iterator __last) {  _M_erase_at_end(std::copy(__last, end(), __first));  return __first; }  void _M_erase_at_end(iterator __pos) {  this-_M_impl._M_finish = __pos; }  // 清除某个位置上的元素 iterator erase(iterator __position) {  if (__position + 1 != end())  std::copy(__position + 1, end(), __position);  --this-_M_impl._M_finish;  return __position; } clear\n// stl_bvector.h  // 清除所有元素 void clear() { \t_M_erase_at_end(begin()); }  void _M_erase_at_end(iterator __pos) {  this-_M_impl._M_finish = __pos; } insert\nvoid _M_insert_aux(iterator __position, bool __x) {  if (this-_M_impl._M_finish._M_p != this-_M_impl._M_end_of_storage) \t{  // 元素后移 \tstd::copy_backward(__position, this-_M_impl._M_finish, \tthis-_M_impl._M_finish + 1); \t// /从安插点开始填入新值  *__position = __x;  // 修改 finish 指针 \t++this-_M_impl._M_finish; \t} \telse \t{ \t// 申请 2 倍的空间 \t// ... \t} } list list 每次插入或删除一个元素，就立即分配或释放一个元素空间。list 对于空间的运用有绝对的精准，一点也不浪费。对于任何位置的元素插入或元素删除，list 永远是常数时间。可以这么理解：vector 对应数组，list 对应链表。\nlist的节点Node // stl_list.h struct _List_node_base {  _List_node_base* _M_next; /// _List_node_base* _M_prev; ///};  /// @if maint An actual node in the %list. @endif templatetypename _Tp struct _List_node : public _List_node_base {  _Tp _M_data; ///}; list的迭代器 STL 的 list 是一个双向链表（double linked-list），迭代器必须具备前移、后移的能力。所以 list 提供的是 Bidirectional Iterators。\nlist 的一个重要性质：插入（insert）、连接（splice）不会造成原有的 list 迭代器失效。这在 vector 中是不成立的。\n// stl_list.h  templatetypename _Tp struct _List_iterator {  typedef _List_iterator_Tp _Self;  typedef _List_node_Tp _Node;   typedef ptrdiff_t difference_type;  typedef std::bidirectional_iterator_tag iterator_category;  typedef _Tp value_type;  typedef _Tp* pointer;  typedef _Tp\u0026 reference;   // 对于迭代器的取值，取的是节点的 data reference operator*() const {  return static_cast_Node*(_M_node)-_M_data; } // 迭代器的成员存取 pointer operator-() const {  return \u0026static_cast_Node*(_M_node)-_M_data; }   // 跌打器加1，就是前进一个节点 _Self\u0026 operator++() {  _M_node = _M_node-_M_next;  return *this; }  // 迭代器减1，就是后退一个节点 _Self\u0026 operator--() {  _M_node = _M_node-_M_prev;  return *this; }  };\t// struct _List_iterator list的数据结构 list 是一个双向的循环链表。\n_Node 可以转换为迭代器类型：\nprotected:  // Note that pointers-to-_Node's can be ctor-converted to  // iterator types.  typedef _List_node_Tp\t_Node; // 取头节点的数值 reference front() { \treturn *begin(); } list的构造与内存管理：constructor, push_bask,insert list 使用 Alloc 做为空间分配器，并另外定义了 _Node_alloc_type ，为的是更方便的以节点大小为分配单位。\n// 使用 Alloc 做为空间分配器 templatetypename _Tp, typename _Alloc  // 每次配置一个节点大小 typedef typename _Alloc::template rebind_List_node_Tp ::other  _Node_alloc_type; // 分配一个节点并返回 _List_node_Tp* _M_get_node() { return _M_impl._Node_alloc_type::allocate(1); }  // 释放一个节点 void _M_put_node(_List_node_Tp* __p) { _M_impl._Node_alloc_type::deallocate(__p, 1); }  // 分配一个节点，并赋初值 _Node* _M_create_node(const value_type\u0026 __x) { \t_Node* __p = this-_M_get_node(); \ttry \t{  _M_get_Tp_allocator().construct(\u0026__p-_M_data, __x); \t} \tcatch(...)  {  _M_put_node(__p);  __throw_exception_again;  } \treturn __p; }   // 删除一个节点 // Erases element at position given. void _M_erase(iterator __position) {  __position._M_node-unhook();  _Node* __n = static_cast_Node*(__position._M_node);  _M_get_Tp_allocator().destroy(\u0026__n-_M_data);  _M_put_node(__n); } // new_allocator.h void destroy(pointer __p) { __p-~_Tp(); } list 提供了很多 constructors：\nexplicit list(const allocator_type\u0026 __a = allocator_type())  : _Base(__a) { } push_back() 将新元素插入到 list 的尾部：\nvoid push_back(const value_type\u0026 __x) {  this-_M_insert(end(), __x); }  // Inserts new element at position given and with value given. void _M_insert(iterator __position, const value_type\u0026 __x) {  _Node* __tmp = _M_create_node(__x);  __tmp-hook(__position._M_node); } 在 list 内的某处插入新节点，首先必须确定安插位置。\nvoid insert(iterator __position, size_type __n, const value_type\u0026 __x) {  list __tmp(__n, __x, _M_get_Node_allocator());  splice(__position, __tmp); }  // example: 在ls链表头插入 ls.insert(ls.begin(), 6); list 不像 vector 那样有可能在空间不足时做重新分配、数据迁移的动作，所以插入前的所有迭代器在插入动作之后都仍然有效。\nlist的元素操作 // 插入一个节点，作为头节点 void push_front(const value_type\u0026 __x)  { this-_M_insert(begin(), __x); }  // 插入一个节点，作为尾节点 void push_back(const value_type\u0026 __x)  { this-_M_insert(end(), __x); }  // 删除迭代器 position 所指节点 iterator erase(iterator __position);  // 删除头节点 void pop_front()  { this-_M_erase(begin()); }  // 删除尾节点 void pop_back() {  this-_M_erase(iterator(this-_M_impl._M_node._M_prev)); } list 内部提供一个所谓的迁移动作（transfer），将某连续范围的元素迁移到某个特定位置之前。\n// Moves the elements from [first,last) before position. void _M_transfer(iterator __position, iterator __first, iterator __last) { \t__position._M_node-transfer(__first._M_node, __last._M_node); } list 公开提供的是所谓的接合动作（splice）：将某连续范围的元素从一个 list 搬移到另一个（或同一个）list 的某个定点。\n// 将x连接到position所指的位置之前 void splice(iterator __position, list\u0026 __x) { \tif (!__x.empty())  {  _M_check_equal_allocators(__x);  this-_M_transfer(__position, __x.begin(), __x.end());  } }  // 将i所指元素连接到__position所指位置之前 void splice(iterator __position, list\u0026 __x, iterator __i) { \titerator __j = __i; \t++__j; \tif (__position == __i || __position == __j) \treturn;  \tif (this != \u0026__x) \t_M_check_equal_allocators(__x);  \tthis-_M_transfer(__position, __i, __j); }  // 将 [first,last) 内的所有元素连接接于 position所指位置之前。 void splice(iterator __position, list\u0026 __x, iterator __first, iterator __last) { \tif (__first != __last) \t{ \tif (this != \u0026__x) \t_M_check_equal_allocators(__x);  \tthis-_M_transfer(__position, __first, __last); \t} } 有了 transfer()，merge()、reverse() 和 sort() 的源码并不难实现。\ntemplatetypename _Tp, typename _Alloc void list_Tp, _Alloc:: merge(list\u0026 __x) {  // _GLIBCXX_RESOLVE_LIB_DEFECTS  // 300. list::merge() specification incomplete  if (this != \u0026__x) \t{ \t_M_check_equal_allocators(__x);  \titerator __first1 = begin(); \titerator __last1 = end(); \titerator __first2 = __x.begin(); \titerator __last2 = __x.end(); \twhile (__first1 != __last1 \u0026\u0026 __first2 != __last2) \tif (*__first2  *__first1) \t{  iterator __next = __first2;  _M_transfer(__first1, __first2, ++__next);  __first2 = __next; \t} \telse \t++__first1; \tif (__first2 != __last2) \t_M_transfer(__last1, __first2, __last2); \t} } deque vector 是单向开口的连续线性空间，也就是说，只能从一端进行插入。deque 则是一种双向开口的连续线性空间，可以在头尾两端分别􏰁做元素的插入和删除动作。\ndeque 在两端插入或删除，时间复杂度都是常数级的。不同于 vector，如果在头插入，需要将所有元素后移，时间复杂度是线性级别的。\n应尽可能选择使用 vector 而非 deque。对 deque 进行的排序动作，为了最高效率，可将 deque 先完整复制到一个 vector 身上，将 vector 排序后（利用 STL sort 算法），再复制回 deque。\ndeque的中控件 deque 由一段一段的定量连续空间构成。一旦有必要在 deque 的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个 deque 的头端或尾端。\n为了维护整体连续的假象，数据结构的设计及迭代器前进后退等动作都颇为繁琐。deque 的代码量远比 vector 或 list 多得多。\ndeque 采用一块 map（一小块连续的控件），其中的每个元素指向另一段较大的连续线性空间，成为缓冲区。缓冲区是 deque 的存储空间主体。\nprotected: \t// 元素的指针的指针\t typedef pointer*\t_Map_pointer;   // 每个node都指向一块缓冲区 _Map_pointer _M_node; deque的迭代器 deque 是分段连续空间。\ntemplatetypename _Tp, typename _Ref, typename _Ptr  struct _Deque_iterator\t// 未继承 std::iterator  {  typedef _Deque_iterator_Tp, _Tp\u0026, _Tp* iterator;  typedef _Deque_iterator_Tp, const _Tp\u0026, const _Tp* const_iterator;   static size_t _S_buffer_size()  { return __deque_buf_size(sizeof(_Tp)); }  \t// 自行撰写 5 个必要的跌打器类型  typedef std::random_access_iterator_tag iterator_category; //(1)  typedef _Tp value_type;\t// (2)  typedef _Ptr pointer;\t// (3)  typedef _Ref reference;\t// (4)  typedef size_t size_type;  typedef ptrdiff_t difference_type;\t// (5)  typedef _Tp** _Map_pointer;  typedef _Deque_iterator _Self;   _Tp* _M_cur;\t// 此迭代器所指缓冲区的当前（current）元素  _Tp* _M_first;\t// 指向缓冲区的头  _Tp* _M_last;\t// 指向缓冲区的尾  _Map_pointer _M_node;\t// 指向控制中心   // ...  }; // 决定缓冲区大小的函数 static size_t _S_buffer_size()  { return __deque_buf_size(sizeof(_Tp)); }  // 如果 sz(元素大小，sizeof(value_type))小于 512，传回 512/sz， // 如果 sz 不小于 512，传回 1。 inline size_t  __deque_buf_size(size_t __size)  { return __size  512 ? size_t(512 / __size) : size_t(1); } begin() 和 end() 所传回的两个迭代器如下图：\n一旦行进时遇到缓冲区边缘，视前进或后退而定，可能需要调用 set_node() 切换缓冲区。\nvoid _M_set_node(_Map_pointer __new_node) { \t_M_node = __new_node; \t_M_first = *__new_node; \t_M_last = _M_first + difference_type(_S_buffer_size()); }  _Self\u0026 operator++() { \t++_M_cur; \tif (_M_cur == _M_last)  {  // 切换下一个节点（即下一个缓冲区） \t_M_set_node(_M_node + 1); \t_M_cur = _M_first;  } \treturn *this; } deque的数据结构 deque 维护 start, finish 两个迭代器，分􏰁指向第一缓冲区的第一个元素和最后缓冲区的最后一个元素（的下一位置）。\n struct _Deque_impl\r: public _Tp_alloc_type\r{\r_Tp** _M_map;\t// 指向map，一块连续的空间\rsize_t _M_map_size;\t// map内的节点数\riterator _M_start;\t// 第一个节点\riterator _M_finish;\t// 最后一个节点\r_Deque_impl(const _Tp_alloc_type\u0026 __a)\r: _Tp_alloc_type(__a), _M_map(0), _M_map_size(0),\r_M_start(), _M_finish()\r{ }\r}; 有了以上的结构，很多操作便可以轻易完成：\n// iterators /** * Returns a read/write iterator that points to the first element in the * %deque. Iteration is done in ordinary element order. */ iterator  begin() { return this-_M_impl._M_start; }  /** * Returns a read/write iterator that points one past the last * element in the %deque. Iteration is done in ordinary * element order. */ iterator  end() { return this-_M_impl._M_finish; } deque的构造与内存管理 deque自行定义了两个专属的空间配置器:\n// 每次分配一个元素大小 typedef _Deque_base_Tp, _Alloc _Base; // 每次分配一个指针大小 typedef typename _Base::_Tp_alloc_type\t_Tp_alloc_type; 并提供 constructor：\nexplicit deque(size_type __n, const value_type\u0026 __value = value_type(), const allocator_type\u0026 __a = allocator_type()) : _Base(__a, __n) { _M_fill_initialize(__value); } _M_fill_initialize()产生并初始化后 deque 的结构：\ntemplate typename _Tp, typename _Alloc  void  deque_Tp, _Alloc::  _M_fill_initialize(const value_type\u0026 __value)  {  _Map_pointer __cur;  try  {  // 为每个节点的缓冲区设定初值  for (__cur = this-_M_impl._M_start._M_node; \t__cur  this-_M_impl._M_finish._M_node; \t++__cur)  std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(), \t__value, _M_get_Tp_allocator());  // 最后一个节点设定不同，尾端可能有备用空间，不必设初值  std::__uninitialized_fill_a(this-_M_impl._M_finish._M_first, \tthis-_M_impl._M_finish._M_cur, \t__value, _M_get_Tp_allocator());  }  catch(...)  {  std::_Destroy(this-_M_impl._M_start, iterator(*__cur, __cur), \t_M_get_Tp_allocator());  __throw_exception_again;  }  } push_back() 函数\nvoid push_back(const value_type\u0026 __x) { \tif (this-_M_impl._M_finish._M_cur \t!= this-_M_impl._M_finish._M_last - 1) \t{ \t// 最后缓冲区尚有一个以上的备用空间 \tthis-_M_impl.construct(this-_M_impl._M_finish._M_cur, __x);\t//直接在备用空间上建构元素 \t++this-_M_impl._M_finish._M_cur;\t//调整最后缓冲区的使用状态 \t} \telse\t// 最后缓冲区已无(或只剩一个)元素备用空间。 \t_M_push_back_aux(__x); }   // 只有当 finish.cur == finish.last – 1时才会被调用。 // 即：当最后一个缓冲区只剩一个备用元素空间时才会被呼叫。 template typename _Tp, typename _Alloc void deque_Tp, _Alloc::  _M_push_back_aux(const value_type\u0026 __t) {  value_type __t_copy = __t;  _M_reserve_map_at_back();\t// // 如果 map尾端的节点备用空间不足,则必须重换一个map  *(this-_M_impl._M_finish._M_node + 1) = this-_M_allocate_node();\t//配置一个新节点(缓冲区)  try  {  this-_M_impl.construct(this-_M_impl._M_finish._M_cur, __t_copy);\t//针对标的元素设值  this-_M_impl._M_finish._M_set_node(this-_M_impl._M_finish._M_node  + 1);\t//改变 finish，令其指向新节点  this-_M_impl._M_finish._M_cur = this-_M_impl._M_finish._M_first;\t//设定finish的状态  }  catch(...)  {  _M_deallocate_node(*(this-_M_impl._M_finish._M_node + 1));  __throw_exception_again;  } } push_front() 函数：\nvoid push_front(const value_type\u0026 __x) {  //第一缓冲区尚有备用空间 \tif (this-_M_impl._M_start._M_cur != this-_M_impl._M_start._M_first) \t{  // 直接在备用空间上建构元素 \tthis-_M_impl.construct(this-_M_impl._M_start._M_cur - 1, __x); \t//调整第一缓冲区的使用状态  --this-_M_impl._M_start._M_cur; \t} \t// 第一缓冲区已无备用空间  else \t_M_push_front_aux(__x); } deque的元素操作pop_back,pop_front,clear,erase,insert 所谓 pop，是将元素拿掉。无论从 deque 的最前端或最尾端取元素，都需考虑在某种条件下，将缓冲区释放掉:\nvoid pop_front() {  // 第一缓冲区有一个(或更多)元素 \tif (this-_M_impl._M_start._M_cur \t!= this-_M_impl._M_start._M_last - 1) \t{  // 将第一元素销毁 \tthis-_M_impl.destroy(this-_M_impl._M_start._M_cur); \t// //调整指针，相当于排除了第一元素  ++this-_M_impl._M_start._M_cur; \t}  // 第一缓冲区仅有一个元素，进行缓冲区的释放工作 \telse \t_M_pop_front_aux(); }  //只有当 start.cur == start.last - 1 时才会被呼叫。 template typename _Tp, typename _Alloc void deque_Tp, _Alloc::  _M_pop_front_aux() {  // 将第一缓冲区的第一个元素解构  this-_M_impl.destroy(this-_M_impl._M_start._M_cur);  // //释放第一缓冲区。  _M_deallocate_node(this-_M_impl._M_start._M_first);  //调整 start的状态  this-_M_impl._M_start._M_set_node(this-_M_impl._M_start._M_node + 1);  // 下一个缓冲区的第一个元素。  this-_M_impl._M_start._M_cur = this-_M_impl._M_start._M_first; } clear()，用来清除整个 deque。请注意，deque 的最初状态（无任何元素时）保有一个缓冲区，因此 clear() 完成之后回复初始状态，也一样要 保留一个缓冲区:\nvoid clear() { _M_erase_at_end(begin()); }  // Called by erase(q1, q2), resize(), clear(), _M_assign_aux, // _M_fill_assign, operator=. void _M_erase_at_end(iterator __pos) { \t_M_destroy_data(__pos, end(), _M_get_Tp_allocator()); \t// +1 的目的是：保留头尾缓冲区  _M_destroy_nodes(__pos._M_node + 1, \tthis-_M_impl._M_finish._M_node + 1); \tthis-_M_impl._M_finish = __pos; } insert()\ntemplate typename _Tp, typename _Alloc typename deque_Tp, _Alloc::iterator deque_Tp, _Alloc:: insert(iterator __position, const value_type\u0026 __x) {  // 如果插入点是 deque最前端  if (__position._M_cur == this-_M_impl._M_start._M_cur) \t{ \tpush_front(__x); \treturn this-_M_impl._M_start; \t}  // 如果插入点是 deque最尾端  else if (__position._M_cur == this-_M_impl._M_finish._M_cur) \t{ \tpush_back(__x); \titerator __tmp = this-_M_impl._M_finish; \t--__tmp; \treturn __tmp; \t}  else  return _M_insert_aux(__position, __x); }    template typename _Tp, typename _Alloc  typename deque_Tp, _Alloc::iterator  deque_Tp, _Alloc::  _M_insert_aux(iterator __pos, const value_type\u0026 __x)  {  // 安插点之前的元素个数  difference_type __index = __pos - this-_M_impl._M_start;  value_type __x_copy = __x; // XXX copy  // 如果安插点之前的元素个数比较少  if (static_castsize_type(__index)  size() / 2)  {  // 在最前端加入与第一元素同值的元素。  push_front(front());  // 以下标示记号，然后进行元素搬移...  iterator __front1 = this-_M_impl._M_start;  ++__front1;  iterator __front2 = __front1;  ++__front2;  __pos = this-_M_impl._M_start + __index;  iterator __pos1 = __pos;  ++__pos1;  // 元素搬移  std::copy(__front2, __pos1, __front1);  }  else\t//安插点之后的元素个数比较少  {  push_back(back());\t// 最尾端插入与最后元素同值的元素  iterator __back1 = this-_M_impl._M_finish;  --__back1;  iterator __back2 = __back1;  --__back2;  __pos = this-_M_impl._M_start + __index;  // 元素搬移  std::copy_backward(__pos, __back2, __back1);  }  // 在插入点设定新值  *__pos = __x_copy;  return __pos;  } stack stack 是一种先进后出（First In Last Out，FILO）的数据结构，它只有一个出口。stack 允许新增元素、移除元素、取得最顶端元素。但除了最顶端外，没有任何其它方法可以存取 stack 的其它元素。\nstack定义式完整列表 以某种既有容器做为底部结构，将其接口改变，使符合「先进后出」的特性，形 成一个 stack，是很容易做到的。deque 是双向开口的数据结构，若以 deque 为 底部结构并封闭其头端开口，便轻而易举地形成了一个 stack。\ntemplate\rclass stack\r{\rprotected:\r// 底层容器\r_Sequence c;\r}; /** Returns true if the %stack is empty. */ bool empty() const { return c.empty(); }  /** Returns the number of elements in the %stack. */ size_type size() const { return c.size(); } stack没有迭代器 stack 所有元素的进出都必须符合「先进后出」的条件，只有 stack 顶端的元素，才有机会被外界取用。 不提供迭代器。\n以list为stack的底层容器 除了deque 之外，list 也是双向开口的数据结构。上述 stack 源码中使用的底层容器的函数有 empty, size, back, push_back, pop_back，list 都具备。\nqueue queue 是一种先进先出（First In First Out，FIFO）的数据结构，它有两个出口。\nqueue 只能从一端插入，另一端删除。除了最底端可以加入、最顶端可以取出，没有任何其它方法可以存取 queue 的其它元素。\nqueue定义式完整列表 SGI STL 便以 deque 做为预设情况下的 queue 底层结构。\ntemplatetypename _Tp, typename _Sequence = deque_Tp  class queue { protected: \t// 底层容器  _Sequence c; }; void push(const value_type\u0026 __x) { \tc.push_back(__x); }  void pop() {  __glibcxx_requires_nonempty();  c.pop_front(); } queue没有迭代器 queue 所有元素的进出都必须符合「先进先出」的条件，只有 queue 顶端的元素，才有机会被外界取用。\n以list做为queue的底层容器 除了deque 之外，list 也是双向开口的数据结构。上述 queue 源码中使用的底层容器的函数有 empty, size, back, push_back, pop_back，list 都具备。\nheap heap 并不归属于 STL 容器组件，它的背后是 priority queue（优先队列）。priority queue 允许使用者以任何次序将任何元素推入容器内，但取出时一定是从优先权最高的元素开始取。\n使用 list 做为 priority queue 的底层机制，元素插入动作可享常数时间。但是要找到 list 中的极值，却需要对整个 list 进行线性扫描。\n使用 binary search tree 做为 priority queue 的底层机制，元素的插入和极值的取得就有 O(logN) 的表现。但是这需要确保输入数据的随机性。\npriority queue 的复杂度，最好介于 queue 和 binary search tree之间，才算适得其所。binary heap 便是这种条件下的适当候选人。\nbinary heap 是一颗完全二叉树。当完全二叉树中的某个节点位于 array 的 i 处，其左子节点必位于 array 的 2i+1 处，其右子节点必位于 array 的 2i+2 处（这里的索引从 0 开始）。\n其父节点必定是 ⌊(i - 1)/2⌋。\n根据元素排列方式，heap 可分为 max-heap 和 min-heap 两种，max-heap 的最大值在根节点，min-heap 的最小值在根节点。\nheap算法 push_heap\n为了保持完全二叉树的性质，应该将新元素插入在底层 vector 的 end() 处。\ntemplatetypename _RandomAccessIterator inline void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) {  std::__push_heap(__first, _DistanceType((__last - __first) - 1),  _DistanceType(0), _ValueType(*(__last - 1))); }   templatetypename _RandomAccessIterator, typename _Compare inline void push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,  _Compare __comp) { \t// 值必置于底部 - 容器的最尾端  std::__push_heap(__first, _DistanceType((__last - __first) - 1),  _DistanceType(0), _ValueType(*(__last - 1)), __comp); }  // 不允许指定，（大小比较标准） templatetypename _RandomAccessIterator, typename _Distance, typename _Tp,  typename _Compare  void  __push_heap(_RandomAccessIterator __first, _Distance __holeIndex, \t_Distance __topIndex, _Tp __value, _Compare __comp) {  _Distance __parent = (__holeIndex - 1) / 2;\t// 父节点  while (__holeIndex  __topIndex\t \u0026\u0026 __comp(*(__first + __parent), __value))  {  // 当尚􏰃到达顶端，且父节点小于新值  *(__first + __holeIndex) = *(__first + __parent);  __holeIndex = __parent;  __parent = (__holeIndex - 1) / 2;  }  *(__first + __holeIndex) = __value; } pop_heap\npop 动作取走根节点，必须将最下一层最右边的叶节点拿来填补跟节点的位置，并维护堆的性质。\ntemplatetypename _RandomAccessIterator  inline void  pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)  {  std::__pop_heap(__first, __last - 1, __last - 1,  _ValueType(*(__last - 1)));  }  templatetypename _RandomAccessIterator, typename _Compare  inline void  pop_heap(_RandomAccessIterator __first,  _RandomAccessIterator __last, _Compare __comp)  {  std::__pop_heap(__first, __last - 1, __last - 1,  _ValueType(*(__last - 1)), __comp);  }  templatetypename _RandomAccessIterator, typename _Tp  inline void  __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,  _RandomAccessIterator __result, _Tp __value)  {  typedef typename iterator_traits_RandomAccessIterator::difference_type  _Distance;  // 设定尾值为首值，于是尾值即为欲求结果  // 可由客端稍后再以底层容器之 pop_back() 取出尾值。  *__result = *__first;  // 以上欲重新调整 heap  std::__adjust_heap(__first, _Distance(0), _Distance(__last - __first),  __value);  }   templatetypename _RandomAccessIterator, typename _Distance,  typename _Tp, typename _Compare  void  __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,  _Distance __len, _Tp __value, _Compare __comp) {  const _Distance __topIndex = __holeIndex;  _Distance __secondChild = 2 * __holeIndex + 2; // 右节点  while (__secondChild  __len)  {  if (__comp(*(__first + __secondChild),  *(__first + (__secondChild - 1))))  __secondChild--; // 减1后为左节点   // secondChild代表较大子节点  *(__first + __holeIndex) = *(__first + __secondChild);  __holeIndex = __secondChild;  __secondChild = 2 * (__secondChild + 1);  }  // 如果没有右节点，只有左子节点  if (__secondChild == __len)  {  *(__first + __holeIndex) = *(__first + (__secondChild - 1));  __holeIndex = __secondChild - 1;  }  std::__push_heap(__first, __holeIndex, __topIndex, __value, __comp); } pop_heap 之后，最大元素只是被置放于底部容器的最尾端，尚􏰃被取走。如果要取其值，可使用底部容器（vector）所提供的 back() 操作函数。如果要移除它，可使用底部容器（vector）所提供的 pop_back() 操作函式。\nsort_heap 排序过后，原来的 heap 就不再是个合法的 heap 了。\n// 每执行一次 pop_heap()，极值(在 STL heap 中为极大值)即被放在尾端。 // 扣除尾端再执行一次 pop_heap()，次极值又被放在新尾端。一直下去，最后即得 // 排序结果。  templatetypename _RandomAccessIterator  void  sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)  {  while (__last - __first  1)  std::pop_heap(__first, _RandomAccessIterator(__last--));  } make_heap 这个算法用来将一段现有的数据转化为一个 heap。\ntemplatevoid\rmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\r{\r// 如果长度为 0或 1，不必重新排列。\rif (__last - __first heap也没有迭代器 priority_queue priority_queue 是一个拥有权值观念的 queue，它允许加入新元素、移除旧元素，审视元素值等功能。由于这是一个 queue，所以只允许在底端加入元素，并从顶端取出元素，除此之外􏰁无其它存取元素的途径。\ntemplate,\rtypename _Compare = less\rclass priority_queue\r{\rprotected:\r// vector为底层容器\r_Sequence c;\r_Compare comp; // 元素大小的比较标准\r// ....\r}; priority_queue也没有迭代器 slist STL list 是个双向链表（double linked list）。SGI STL 另提供了一个单向串行（single linked list），名为slist。 slist 和 list 的主要差􏰁在于，前者的迭代器属于单向的 Forward Iterator，后者的迭代器属于双向的 Bidirectional Iterator。 slist 和 list 共同具有的一个相同特色是，它们的插入（insert）、移除（erase）、接合（splice）等动作并不会造成原有的迭代器失效。\n基于效率考虑，slist 不提供 push_back()，只提供 push_front()。\nslist的节点 // 单向串行的节点基􏰀结构  struct _Slist_node_base  {  _Slist_node_base* _M_next;  };   // 单向串行的节点结构  template class _Tp  struct _Slist_node : public _Slist_node_base  {  _Tp _M_data;  };   //已知某一节点，安插新节点于其后。  inline _Slist_node_base*  __slist_make_link(_Slist_node_base* __prev_node,  _Slist_node_base* __new_node)  {  __new_node-_M_next = __prev_node-_M_next;  __prev_node-_M_next = __new_node;  return __new_node;  }   // 反转一个链表  inline _Slist_node_base*  __slist_reverse(_Slist_node_base* __node)  {  _Slist_node_base* __result = __node;  __node = __node-_M_next;  __result-_M_next = 0;  while(__node)  {  _Slist_node_base* __next = __node-_M_next;  __node-_M_next = __result;  __result = __node;  __node = __next;  }  return __result;  } slist的迭代器 //单向串行的迭代器基􏰀结构  struct _Slist_iterator_base  {  typedef size_t size_type;  typedef ptrdiff_t difference_type;  typedef std::forward_iterator_tag iterator_category; // 单向   _Slist_node_base* _M_node; //指向节点基􏰀结构   void _M_incr() // // 前进一个节点  { _M_node = _M_node-_M_next; }   // ....  };   //单向串行的迭代器结构  template class _Tp, class _Ref, class _Ptr  struct _Slist_iterator : public _Slist_iterator_base  {  typedef _Slist_iterator_Tp, _Tp\u0026, _Tp* iterator;  typedef _Slist_iterator_Tp, const _Tp\u0026, const _Tp* const_iterator;  typedef _Slist_iterator_Tp, _Ref, _Ptr _Self;   _Self\u0026  operator++()  {  _M_incr(); // //前进一个节点  return *this;  }   _Self  operator++(int)  {  _Self __tmp = *this;  _M_incr(); // //前进一个节点  return __tmp;  }  }; slist的数据结构 template class _Tp, class _Alloc = allocator_Tp   class slist : private _Slist_base_Tp,_Alloc  {  // concept requirements  __glibcxx_class_requires(_Tp, _SGIAssignableConcept)   private:  typedef _Slist_base_Tp,_Alloc _Base;   public:  typedef _Tp value_type;  typedef value_type* pointer;  typedef const value_type* const_pointer;  typedef value_type\u0026 reference;  typedef const value_type\u0026 const_reference;  typedef size_t size_type;  typedef ptrdiff_t difference_type;   typedef _Slist_iterator_Tp, _Tp\u0026, _Tp* iterator;  typedef _Slist_iterator_Tp, const _Tp\u0026, const _Tp* const_iterator;   typedef typename _Base::allocator_type allocator_type;  private:  typedef _Slist_node_Tp _Node;  typedef _Slist_node_base _Node_base;  typedef _Slist_iterator_base _Iterator_base;   _Node*  _M_create_node(const value_type\u0026 __x)  {  // 配置空间  _Node* __node = this-_M_get_node();  try  {  // 构造元素  get_allocator().construct(\u0026__node-_M_data, __x);  __node-_M_next = 0;  }  catch(...)  {  this-_M_put_node(__node);  __throw_exception_again;  }  return __node;  }  };   iterator  begin()  { return iterator((_Node*)this-_M_head._M_next); }   iterator  end()  { return iterator(0); }   bool  empty() const  { return this-_M_head._M_next == 0; }   void  swap(slist\u0026 __x)  { std::swap(this-_M_head._M_next, __x._M_head._M_next); }   // 取头部元素  reference  front()  { return ((_Node*) this-_M_head._M_next)-_M_data; }   // 删除头部元素  void  pop_front()  {  _Node* __node = (_Node*) this-_M_head._M_next;  this-_M_head._M_next = __node-_M_next;  get_allocator().destroy(\u0026__node-_M_data);  this-_M_put_node(__node);  } }; ",
  "wordCount" : "11209",
  "inLanguage": "en",
  "datePublished": "2019-03-04T17:22:19+08:00",
  "dateModified": "2019-03-04T17:22:19+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://landodo.github.io/posts/20190304-stl-notes/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Landodo's NoteBook",
    "logo": {
      "@type": "ImageObject",
      "url": "http://landodo.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://landodo.github.io/" accesskey="h" title="Landodo&#39;s NoteBook (Alt + H)">Landodo&#39;s NoteBook</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="http://landodo.github.io/search" title="🔍Search (Alt &#43; /)" accesskey=/>
                    <span>🔍Search</span>
                </a>
            </li>
            <li>
                <a href="http://landodo.github.io/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="http://landodo.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://landodo.github.io/tags" title="Tag">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="http://landodo.github.io/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="http://landodo.github.io/cs-zoo" title="CS ZOO">
                    <span>CS ZOO</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://landodo.github.io/">Home</a>&nbsp;»&nbsp;<a href="http://landodo.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      《STL 源码剖析》STL 学习笔记
    </h1>
    <div class="post-meta"><span title='2019-03-04 17:22:19 +0800 CST'>March 4, 2019</span>&nbsp;·&nbsp;23 min&nbsp;·&nbsp;11209 words

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#stl%e6%ba%90%e7%a0%81%e5%89%96%e6%9e%90" aria-label="STL源码剖析">STL源码剖析</a><ul>
                        
                <li>
                    <a href="#stl%e6%a6%82%e8%bf%b0%e4%b8%8e%e7%89%88%e6%9c%ac%e7%ae%80%e4%bb%8b" aria-label="STL概述与版本简介">STL概述与版本简介</a><ul>
                        
                <li>
                    <a href="#stl%e7%9a%84%e5%8e%86%e5%8f%b2" aria-label="STL的历史">STL的历史</a></li>
                <li>
                    <a href="#stl%e4%b8%8ec%e6%a0%87%e5%87%86%e9%93%be%e6%8e%a5%e5%ba%93" aria-label="STL与C&#43;&#43;标准链接库">STL与C++标准链接库</a></li>
                <li>
                    <a href="#stl%e5%85%ad%e5%a4%a7%e7%bb%84%e4%bb%b6" aria-label="STL六大组件">STL六大组件</a><ul>
                        
                <li>
                    <a href="#c%e8%a7%84%e8%8c%83" aria-label="C&#43;&#43;规范">C++规范</a></li></ul>
                </li>
                <li>
                    <a href="#gnu%e6%ba%90%e7%a0%81%e5%bc%80%e6%94%be%e7%b2%be%e7%a5%9e" aria-label="GNU源码开放精神">GNU源码开放精神</a></li>
                <li>
                    <a href="#hp%e7%89%88%e6%9c%ac" aria-label="HP版本">HP版本</a></li>
                <li>
                    <a href="#sgi-stl%e7%89%88%e6%9c%ac" aria-label="SGI-STL版本">SGI-STL版本</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%a9%ba%e9%97%b4%e5%88%86%e9%85%8d%e5%99%a8allocators" aria-label="空间分配器（allocators）">空间分配器（allocators）</a><ul>
                        
                <li>
                    <a href="#%e5%88%86%e9%85%8d%e5%99%a8%e7%9a%84%e6%a0%87%e5%87%86%e6%8e%a5%e5%8f%a3" aria-label="分配器的标准接口">分配器的标准接口</a></li>
                <li>
                    <a href="#%e8%ae%be%e8%ae%a1%e5%88%86%e9%85%8d%e5%99%a8" aria-label="设计分配器">设计分配器</a></li>
                <li>
                    <a href="#%e4%ba%8c%e7%ba%a7%e5%88%86%e9%85%8dsub-allocation%e7%9a%84sgi%e7%a9%ba%e9%97%b4%e5%88%86%e9%85%8d%e5%99%a8" aria-label="二级分配（sub-allocation）的SGI空间分配器">二级分配（sub-allocation）的SGI空间分配器</a><ul>
                        
                <li>
                    <a href="#sgi%e6%a0%87%e5%87%86%e7%9a%84%e7%a9%ba%e9%97%b4%e5%88%86%e9%85%8d%e5%99%a8stdallocator" aria-label="SGI标准的空间分配器std::allocator">SGI标准的空间分配器std::allocator</a></li>
                <li>
                    <a href="#sgi%e7%89%b9%e6%ae%8a%e7%9a%84%e7%a9%ba%e9%97%b4%e5%88%86%e9%85%8d%e5%99%a8stdalloc" aria-label="SGI特殊的空间分配器std::alloc">SGI特殊的空间分配器std::alloc</a></li>
                <li>
                    <a href="#%e5%af%b9%e8%b1%a1%e7%9a%84%e6%9e%84%e9%80%a0%e5%92%8c%e9%94%80%e6%af%81construct%e5%92%8cdestroy" aria-label="对象的构造和销毁：construct()和destroy()">对象的构造和销毁：construct()和destroy()</a></li>
                <li>
                    <a href="#%e7%a9%ba%e9%97%b4%e7%9a%84%e7%94%b3%e8%af%b7%e4%b8%8e%e9%87%8a%e6%94%bestdalloc" aria-label="空间的申请与释放std::alloc">空间的申请与释放std::alloc</a></li>
                <li>
                    <a href="#%e7%ac%ac%e4%b8%80%e7%ba%a7%e5%88%86%e9%85%8d%e5%99%a8" aria-label="第一级分配器">第一级分配器</a></li>
                <li>
                    <a href="#%e7%ac%ac%e4%ba%8c%e7%ba%a7%e5%88%86%e9%85%8d%e5%99%a8" aria-label="第二级分配器">第二级分配器</a></li>
                <li>
                    <a href="#%e6%8e%a7%e4%bb%b6%e5%88%86%e9%85%8d%e5%87%bd%e6%95%b0allocate" aria-label="控件分配函数allocate()">控件分配函数allocate()</a></li>
                <li>
                    <a href="#%e6%8e%a7%e4%bb%b6%e9%87%8a%e6%94%be%e5%87%bd%e6%95%b0deallocate" aria-label="控件释放函数deallocate()">控件释放函数deallocate()</a></li>
                <li>
                    <a href="#%e9%87%8d%e6%96%b0%e5%a1%ab%e5%85%85free-list" aria-label="重新填充free list">重新填充free list</a></li>
                <li>
                    <a href="#%e5%86%85%e5%ad%98%e6%b1%a0memory-pool" aria-label="内存池（memory pool）">内存池（memory pool）</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%86%85%e5%ad%98%e5%9f%ba%e6%9c%ac%e5%a4%84%e7%90%86%e5%b7%a5%e5%85%b7" aria-label="内存基本处理工具">内存基本处理工具</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%bf%ad%e4%bb%a3%e5%99%a8iterators" aria-label="迭代器（iterators）">迭代器（iterators）</a><ul>
                        
                <li>
                    <a href="#%e8%bf%ad%e4%bb%a3%e5%99%a8%e7%9a%84%e8%ae%be%e8%ae%a1%e6%80%9d%e7%bb%b4stl%e7%9a%84%e5%85%b3%e9%94%ae" aria-label="迭代器的设计思维——STL的关键">迭代器的设计思维——STL的关键</a></li>
                <li>
                    <a href="#%e8%bf%ad%e4%bb%a3%e5%99%a8%e6%98%af%e4%b8%80%e7%a7%8dsmart-pointer" aria-label="迭代器是一种smart-pointer">迭代器是一种smart-pointer</a></li>
                <li>
                    <a href="#%e8%bf%ad%e4%bb%a3%e5%99%a8%e7%9b%b8%e5%ba%94%e7%b1%bb%e5%9e%8b" aria-label="迭代器相应类型">迭代器相应类型</a></li>
                <li>
                    <a href="#traits%e7%bc%96%e7%a8%8b%e6%8a%80%e5%b7%a7" aria-label="Traits编程技巧">Traits编程技巧</a><ul>
                        
                <li>
                    <a href="#partial-specialization%e5%81%8f%e7%89%b9%e5%8c%96%e7%9a%84%e6%84%8f%e4%b9%89" aria-label="Partial Specialization（偏特化）的意义">Partial Specialization（偏特化）的意义</a></li></ul>
                </li>
                <li>
                    <a href="#iterator-%e6%ba%90%e7%a0%81" aria-label="iterator 源码">iterator 源码</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ba%8f%e5%88%97%e5%bc%8f%e5%ae%b9%e5%99%a8sequence-containers" aria-label="序列式容器（sequence containers）">序列式容器（sequence containers）</a><ul>
                        
                <li>
                    <a href="#vector" aria-label="vector">vector</a><ul>
                        
                <li>
                    <a href="#vector%e7%9a%84%e8%bf%ad%e4%bb%a3%e5%99%a8" aria-label="vector的迭代器">vector的迭代器</a></li>
                <li>
                    <a href="#vector%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="vector的数据结构">vector的数据结构</a></li>
                <li>
                    <a href="#vector%e7%9a%84%e6%9e%84%e9%80%a0%e4%b8%8e%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86constructorpush_back" aria-label="vector的构造与内存管理constructor,push_back">vector的构造与内存管理constructor,push_back</a></li>
                <li>
                    <a href="#vector%e7%9a%84%e5%85%83%e7%b4%a0%e6%93%8d%e4%bd%9cpop_backeraseclearinsert" aria-label="vector的元素操作pop_back,erase,clear,insert">vector的元素操作pop_back,erase,clear,insert</a></li></ul>
                </li>
                <li>
                    <a href="#list" aria-label="list">list</a><ul>
                        
                <li>
                    <a href="#list%e7%9a%84%e8%8a%82%e7%82%b9node" aria-label="list的节点Node">list的节点Node</a></li>
                <li>
                    <a href="#list%e7%9a%84%e8%bf%ad%e4%bb%a3%e5%99%a8" aria-label="list的迭代器">list的迭代器</a></li>
                <li>
                    <a href="#list%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="list的数据结构">list的数据结构</a></li>
                <li>
                    <a href="#list%e7%9a%84%e6%9e%84%e9%80%a0%e4%b8%8e%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86constructor-push_baskinsert" aria-label="list的构造与内存管理：constructor, push_bask,insert">list的构造与内存管理：constructor, push_bask,insert</a></li>
                <li>
                    <a href="#list%e7%9a%84%e5%85%83%e7%b4%a0%e6%93%8d%e4%bd%9c" aria-label="list的元素操作">list的元素操作</a></li></ul>
                </li>
                <li>
                    <a href="#deque" aria-label="deque">deque</a><ul>
                        
                <li>
                    <a href="#deque%e7%9a%84%e4%b8%ad%e6%8e%a7%e4%bb%b6" aria-label="deque的中控件">deque的中控件</a></li>
                <li>
                    <a href="#deque%e7%9a%84%e8%bf%ad%e4%bb%a3%e5%99%a8" aria-label="deque的迭代器">deque的迭代器</a></li>
                <li>
                    <a href="#deque%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="deque的数据结构">deque的数据结构</a></li>
                <li>
                    <a href="#deque%e7%9a%84%e6%9e%84%e9%80%a0%e4%b8%8e%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86" aria-label="deque的构造与内存管理">deque的构造与内存管理</a></li>
                <li>
                    <a href="#deque%e7%9a%84%e5%85%83%e7%b4%a0%e6%93%8d%e4%bd%9cpop_backpop_frontcleareraseinsert" aria-label="deque的元素操作pop_back,pop_front,clear,erase,insert">deque的元素操作pop_back,pop_front,clear,erase,insert</a></li></ul>
                </li>
                <li>
                    <a href="#stack" aria-label="stack">stack</a><ul>
                        
                <li>
                    <a href="#stack%e5%ae%9a%e4%b9%89%e5%bc%8f%e5%ae%8c%e6%95%b4%e5%88%97%e8%a1%a8" aria-label="stack定义式完整列表">stack定义式完整列表</a></li>
                <li>
                    <a href="#stack%e6%b2%a1%e6%9c%89%e8%bf%ad%e4%bb%a3%e5%99%a8" aria-label="stack没有迭代器">stack没有迭代器</a></li>
                <li>
                    <a href="#%e4%bb%a5list%e4%b8%bastack%e7%9a%84%e5%ba%95%e5%b1%82%e5%ae%b9%e5%99%a8" aria-label="以list为stack的底层容器">以list为stack的底层容器</a></li></ul>
                </li>
                <li>
                    <a href="#queue" aria-label="queue">queue</a><ul>
                        
                <li>
                    <a href="#queue%e5%ae%9a%e4%b9%89%e5%bc%8f%e5%ae%8c%e6%95%b4%e5%88%97%e8%a1%a8" aria-label="queue定义式完整列表">queue定义式完整列表</a></li>
                <li>
                    <a href="#queue%e6%b2%a1%e6%9c%89%e8%bf%ad%e4%bb%a3%e5%99%a8" aria-label="queue没有迭代器">queue没有迭代器</a></li>
                <li>
                    <a href="#%e4%bb%a5list%e5%81%9a%e4%b8%baqueue%e7%9a%84%e5%ba%95%e5%b1%82%e5%ae%b9%e5%99%a8" aria-label="以list做为queue的底层容器">以list做为queue的底层容器</a></li></ul>
                </li>
                <li>
                    <a href="#heap" aria-label="heap">heap</a><ul>
                        
                <li>
                    <a href="#heap%e7%ae%97%e6%b3%95" aria-label="heap算法">heap算法</a></li>
                <li>
                    <a href="#heap%e4%b9%9f%e6%b2%a1%e6%9c%89%e8%bf%ad%e4%bb%a3%e5%99%a8" aria-label="heap也没有迭代器">heap也没有迭代器</a></li></ul>
                </li>
                <li>
                    <a href="#priority_queue" aria-label="priority_queue">priority_queue</a><ul>
                        
                <li>
                    <a href="#priority_queue%e4%b9%9f%e6%b2%a1%e6%9c%89%e8%bf%ad%e4%bb%a3%e5%99%a8" aria-label="priority_queue也没有迭代器">priority_queue也没有迭代器</a></li></ul>
                </li>
                <li>
                    <a href="#slist" aria-label="slist">slist</a><ul>
                        
                <li>
                    <a href="#slist%e7%9a%84%e8%8a%82%e7%82%b9" aria-label="slist的节点">slist的节点</a></li></ul>
                </li>
                <li>
                    <a href="#slist%e7%9a%84%e8%bf%ad%e4%bb%a3%e5%99%a8" aria-label="slist的迭代器">slist的迭代器</a><ul>
                        
                <li>
                    <a href="#slist%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="slist的数据结构">slist的数据结构</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>这是我学习 STL 的笔记。</p>
<p><strong>更新日志</strong></p>
<ul>
<li>2019-03-04</li>
</ul>
<p>新增了[STL 概述与版本简介](#STL 概述与版本简介)、<a href="#%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%99%A8%EF%BC%88allocators%EF%BC%89">空间分配器（allocators）</a>、<a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88iterators%EF%BC%89">迭代器（iterators）</a>、<a href="#vector">序列式容器-vector</a></p>
<ul>
<li>2019-03-05</li>
</ul>
<p>增加了<a href="#list">list</a></p>
<ul>
<li>2019-03-06</li>
</ul>
<p>增加了 <a href="#deque">deque</a>、<a href="#heap">heap</a>、<a href="#priority_queue">priority_queue</a>、<a href="#slist">slist</a></p>
<hr>
<h1 id="stl源码剖析">STL源码剖析<a hidden class="anchor" aria-hidden="true" href="#stl源码剖析">#</a></h1>
<p><img loading="lazy" src="./20190304/stl-overview.png" alt=""  />
</p>
<p>SGI STL 版本源码的可读性极佳，运用也最为广泛，是 GNU C++ 的标准链接库，并且开放自由。</p>
<p>日常编程广泛运用的各种数据结构（data structures）和算法（algorithms）在 STL 中有良好的实现，连内存配置与管理也都重重考虑了最佳效能。</p>
<p>STL 源码中有着 vector、list、heap、deque、RB-tree、hash-table、set/map，以及各种算法（排序、搜索、排列组合……）的底层实现。</p>
<p>从技术研究与本质提升的角度看，探究 STL 的细节可以帮助彻底的掌握一切，获得深厚扎实的基础。</p>
<p>SGI STL 称得上是一个一流作品，追踪一流作品并且吸取养分，远比自己关起门来写个三流作品，价值高得多。</p>
<h2 id="stl概述与版本简介">STL概述与版本简介<a hidden class="anchor" aria-hidden="true" href="#stl概述与版本简介">#</a></h2>
<p><img loading="lazy" src="./20190304/1-1.png" alt=""  />
</p>
<p>为了建立数据结构和算法的一套标准，并且降低其间的耦合（coupling）关系以提升各自的独立性、弹性、交互操作性（相互合作性，interoperability），STL 诞生了。</p>
<p>STL 带来了一个高层次的、以泛型思维（Generic Paradigm）为基础的、系统化的、条理分明的「软件组件分类学（components taxonomy）」。</p>
<h3 id="stl的历史">STL的历史<a hidden class="anchor" aria-hidden="true" href="#stl的历史">#</a></h3>
<p>STL 的创始人：Alexander Stepanov。</p>
<p>Alexander Stepanov 分别􏰄实验了多种架构和算法公式，先以 C 完成，而后再以 C++ 完成。1993 年 11 月完成正式提案，STL 成为 C++ 标准规格的一部分。</p>
<h3 id="stl与c标准链接库">STL与C++标准链接库<a hidden class="anchor" aria-hidden="true" href="#stl与c标准链接库">#</a></h3>
<p>Alexander 向 C++ 标准委员提交提案后，STL 在会议中取得了压倒性的胜利。STL 进入了 C++ 标准化的正式流程，C++ 链接库如 stream, string 等也都以template 重新写过 。</p>
<h3 id="stl六大组件">STL六大组件<a hidden class="anchor" aria-hidden="true" href="#stl六大组件">#</a></h3>
<ol>
<li>容器（containers）</li>
</ol>
<p>各种数据结构，如 vector, list, deque, set, map。可以理解为包含对象的类。</p>
<ol start="2">
<li>算法（algorithms）</li>
</ol>
<p>各种常用算法如 sort, search, copy, erase。适用于不同类型容器的函数。</p>
<ol start="3">
<li>迭代器（iterators）</li>
</ol>
<p>容器中的“指针”。</p>
<ol start="4">
<li>仿函式（functors）</li>
</ol>
<p>STL 包括重载函数调用操作符的类。类的实例称为函数对象或仿函数。函数允许在传递参数的帮助下自定义相关函数的工作。</p>
<ol start="5">
<li>适配器（adapters）</li>
</ol>
<p>修饰容器（containers）或仿函式（functors）或迭代器（iterators）。</p>
<ol start="6">
<li>分配器（allocators）</li>
</ol>
<p>负责空间分配与管理，即用于分配空间的对象。</p>
<p><img loading="lazy" src="./20190304/1-2.png" alt=""  />
</p>
<h4 id="c规范">C++规范<a hidden class="anchor" aria-hidden="true" href="#c规范">#</a></h4>
<p>使用无拓展名的头文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span></code></pre></div><h3 id="gnu源码开放精神">GNU源码开放精神<a hidden class="anchor" aria-hidden="true" href="#gnu源码开放精神">#</a></h3>
<p>STL 源码属于 HP 公司拥有，每一个头文件重都有声明。开放源码的精神，一般统称为 open source。</p>
<p>Stallman 于 1984 创立自由软件基金会（Free Software Foundation），简称FSF。</p>
<h3 id="hp版本">HP版本<a hidden class="anchor" aria-hidden="true" href="#hp版本">#</a></h3>
<p>每一个 HP STL 头文件都有如下一份声明。</p>
<pre tabindex="0"><code> * Copyright (c) 1994
 * Hewlett-Packard Company
</code></pre><h3 id="sgi-stl版本">SGI-STL版本<a hidden class="anchor" aria-hidden="true" href="#sgi-stl版本">#</a></h3>
<p>SGI 版􏰁由 Silicon Graphics Computer Systems, Inc. 公司发展，承继 HP 版􏰁。它的每一个头文件也都有 HP 的版􏰁本声明。</p>
<pre tabindex="0"><code> * Copyright (c) 1996
 * Silicon Graphics Computer Systems, Inc.
</code></pre><p>在我的设备上，STL 源码位于以下目录：</p>
<pre tabindex="0"><code>/usr/include/c++/4.2.1
</code></pre><p>每一份 STL 源码都包含三个版权声明，如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span> Copyright (c) <span style="color:#ae81ff">1994</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span> Hewlett<span style="color:#f92672">-</span>Packard Company
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span> Copyright (c) <span style="color:#ae81ff">1996</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span> Silicon Graphics Computer Systems, Inc.
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">/** @file include/vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  This is a Standard C++ Library header.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span></code></pre></div><h2 id="空间分配器allocators">空间分配器（allocators）<a hidden class="anchor" aria-hidden="true" href="#空间分配器allocators">#</a></h2>
<p><img loading="lazy" src="./20190304/2.png" alt=""  />
</p>
<p>整个 STL 的操作对象（所有的数值）都存放在容器之内，而容器一定需要分配空间以置放数据。</p>
<pre tabindex="0"><code>array_allocator.h
bitmap_allocator.h
debug_allocator.h		# 可以包装任意其它的allocato
malloc_allocator.h	# 包装malloc和free
mt_allocator.h
new_allocator.h  		# 默认使用的allocator
pool_allocator.h		# 唯一一个带内存池的allocator
throw_allocator.h
</code></pre><h3 id="分配器的标准接口">分配器的标准接口<a hidden class="anchor" aria-hidden="true" href="#分配器的标准接口">#</a></h3>
<p>打开 new_allocator.h，可以看到 allocator 所提供的接口。</p>
<p><img loading="lazy" src="./20190304/2-2.png" alt=""  />
</p>
<h3 id="设计分配器">设计分配器<a hidden class="anchor" aria-hidden="true" href="#设计分配器">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>src<span style="color:#f92672">/</span>my_allocator.h
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>src<span style="color:#f92672">/</span>test_my_allocator.cc
</span></span></code></pre></div><h3 id="二级分配sub-allocation的sgi空间分配器">二级分配（sub-allocation）的SGI空间分配器<a hidden class="anchor" aria-hidden="true" href="#二级分配sub-allocation的sgi空间分配器">#</a></h3>
<pre tabindex="0"><code>vector&lt;int, std::allocator&lt;int&gt; &gt; iv;
</code></pre><h4 id="sgi标准的空间分配器stdallocator">SGI标准的空间分配器std::allocator<a hidden class="anchor" aria-hidden="true" href="#sgi标准的空间分配器stdallocator">#</a></h4>
<p>SGI 定义有一个符合部分标准、名为 allocator 的分配器，但是效率不高，只把 C++ 的 ::operator new 和 ::operator delete 做一层封装而已。</p>
<h4 id="sgi特殊的空间分配器stdalloc">SGI特殊的空间分配器std::alloc<a hidden class="anchor" aria-hidden="true" href="#sgi特殊的空间分配器stdalloc">#</a></h4>
<p>STL allocator 将内存申请由 alloc:allocate() 负责，内存释放由 alloc::deallocate() 负责，对象构造由::construct() 负责，对象销毁由 ::destroy() 负责。</p>
<p>配置器定义于 <code>&lt;memory&gt;</code> 文件中， <code>&lt;memory&gt;</code> 中包含：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/allocator.h&gt;			// 负责内存空间的配置与释放</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stl_construct.h&gt;	// 负责对象的构建与销毁</span><span style="color:#75715e">
</span></span></span></code></pre></div><h4 id="对象的构造和销毁construct和destroy">对象的构造和销毁：construct()和destroy()<a hidden class="anchor" aria-hidden="true" href="#对象的构造和销毁construct和destroy">#</a></h4>
<p><code>stl_construct.h</code> 中包含以下函数：</p>
<p><img loading="lazy" src="./20190304/2-3.png" alt=""  />
</p>
<p>_Construct() 接受一个指针 p 和一个初值 value，此函式的用途就是将初值设定到指针所指的空间上。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// 销毁将指针所指东西
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>_Destroy(_Tp<span style="color:#f92672">*</span> __pointer)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 销毁[first, last]之间的东西
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>_Destroy(_ForwardIterator __first, _ForwardIterator __last)
</span></span></code></pre></div><h4 id="空间的申请与释放stdalloc">空间的申请与释放std::alloc<a hidden class="anchor" aria-hidden="true" href="#空间的申请与释放stdalloc">#</a></h4>
<p>空间的申请、释放由 <code>&lt;malloc_allocator.h&gt;</code> 负责。</p>
<p>SGI 设计了双层级分配器，第一级分配器直接使用 malloc() 和 free()，第二级分配器则视情况采用不同的策略：当分配空间超过 128bytes，便呼叫第一级分配器；当分配空间小于 128bytes，为了降低额外负担，便采用复杂的 memory pool 整理方式，而不再求助于第一级分配器。</p>
<h4 id="第一级分配器">第一级分配器<a hidden class="anchor" aria-hidden="true" href="#第一级分配器">#</a></h4>
<p>第一级分配器直接使用 <code>malloc()</code>，SGI 以 malloc 而非 ::operator new 来分配内存。</p>
<h4 id="第二级分配器">第二级分配器<a hidden class="anchor" aria-hidden="true" href="#第二级分配器">#</a></h4>
<p>第二级分配器多了一些机制，避免􏰃多小额区块造成内存的碎片。当区块小于 128 bytes，则以 <strong>memory pool</strong> 管理，此法又称为二级分配（sub-allocation）：每次配置一大块内存，并维护对应之自由表（free-list）。下次若再有相同大小的内存需求，就直接从 free-lists 中分出。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// pool_allocator.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">union</span> <span style="color:#a6e22e">_Obj</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">union</span> <span style="color:#a6e22e">_Obj</span><span style="color:#f92672">*</span> _M_free_list_link;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span>        _M_client_data[<span style="color:#ae81ff">1</span>];    <span style="color:#75715e">// The client sees this.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><h4 id="控件分配函数allocate">控件分配函数allocate()<a hidden class="anchor" aria-hidden="true" href="#控件分配函数allocate">#</a></h4>
<p>此函数首先判断区块大小，大于 128 bytes 就调用第一级分配器，小于 128 bytes  就检查对应的 free list。如果 free list 中有可用的区块，就直接拿来用，如果没有可用区块，就将区块大小上调至 8 倍数边界，然后呼叫refill()，准备为 free list 重新填充空间。</p>
<h4 id="控件释放函数deallocate">控件释放函数deallocate()<a hidden class="anchor" aria-hidden="true" href="#控件释放函数deallocate">#</a></h4>
<p>此函数首先判断区块大小，大于 128 bytes 就调用第一级分配器，小于 128 bytes 就找出对应的 free list，将区块回收。</p>
<h4 id="重新填充free-list">重新填充free list<a hidden class="anchor" aria-hidden="true" href="#重新填充free-list">#</a></h4>
<p>free list 中没有可用区块了，就呼叫 refill() 为 free list 重新填充空间。</p>
<h4 id="内存池memory-pool">内存池（memory pool）<a hidden class="anchor" aria-hidden="true" href="#内存池memory-pool">#</a></h4>
<p>判断内存池的剩余容量，然后将空间分配给 free list。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">// 判断内存池的剩余容量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>end_free <span style="color:#f92672">-</span> start_free
</span></span></code></pre></div><h3 id="内存基本处理工具">内存基本处理工具<a hidden class="anchor" aria-hidden="true" href="#内存基本处理工具">#</a></h3>
<p>STL 定义有五个函数，作用于􏰅初始化空间上。</p>
<p>前两个是 construct() 和 destroy()，另外三个函数位于 <code>&lt;stl_uninitialized.h&gt;</code> 中。</p>
<p><img loading="lazy" src="./20190304/2-4.png" alt=""  />
</p>
<p><strong>uninitialized_copy()</strong></p>
<p>将内存的分配与对象的构造行为分离开来。</p>
<p>它接收 3 个参数：</p>
<ol>
<li>迭代器 first 指向输入端的起始位置</li>
<li>迭代器 last 指向输入端的结束位置</li>
<li>迭代器 result 指向输出端（欲初始化空间）的起始处</li>
</ol>
<p><strong>uninitialized_fill()</strong></p>
<p>将内存的分配与对象的构造行为分离开来，它要不就产生出所有必要元素，要不就不产生任何元素。</p>
<p>它接收 3 个参数：</p>
<ol>
<li>迭代器 first 指向输出端（欲初始化空间）的起始处</li>
<li>迭代器 last 指向输出端（欲初始化空间）的结束处</li>
<li>x 表示初值</li>
</ol>
<p><strong>uninitialized_fill_n()</strong></p>
<p>将内存的分配与对象的构造行为分离开来，它会为指定范围内的所有元素设定相同的初值。</p>
<p>它接收 3 个参数：</p>
<ol>
<li>first：指向欲初始化空间的起始处</li>
<li>n：表示欲初始化空间的大小</li>
<li>x：初值</li>
</ol>
<h2 id="迭代器iterators">迭代器（iterators）<a hidden class="anchor" aria-hidden="true" href="#迭代器iterators">#</a></h2>
<p><img loading="lazy" src="./20190304/3-1.png" alt=""  />
</p>
<p>iterator：提供一种方法，是的得可以按顺序访问某个聚合物（容器）所􏰈的各个元素，而又不会暴露该聚合物（容器）的内部实现。</p>
<h3 id="迭代器的设计思维stl的关键">迭代器的设计思维——STL的关键<a hidden class="anchor" aria-hidden="true" href="#迭代器的设计思维stl的关键">#</a></h3>
<p>STL 的中心思想在于，将数据容器（containers）和算法（algorithms）分开，彼此独立设计，最后再以一种粘合剂将它们联系在一起。迭代器（iterators）就是联系容器（containers）和算法（algorithms）的粘合剂。</p>
<h3 id="迭代器是一种smart-pointer">迭代器是一种smart-pointer<a hidden class="anchor" aria-hidden="true" href="#迭代器是一种smart-pointer">#</a></h3>
<p>迭代器是一种行为类似指针的对象，而指针的各种行为中最常见也最重要的便是内容提领（dereference）和成员取用（member access）。迭代器最重要的编程工作就是对 operator* 和 operator-&gt; 进行重载（overloading）工程。</p>
<p>auto_ptr 的源码在头文件 <code>&lt;memory&gt;</code> 中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> _Tp<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">auto_ptr</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  _Tp<span style="color:#f92672">*</span> _M_ptr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//....
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>每一种 STL 容器都提供有专属迭代器，目的就是为了封装细节不被使用者所看到。</p>
<h3 id="迭代器相应类型">迭代器相应类型<a hidden class="anchor" aria-hidden="true" href="#迭代器相应类型">#</a></h3>
<p>算法之中运用迭代器时，很可能会用到其相应类型􏰄（associated type）。</p>
<p>可以使用利用 function template 的自变量推导（argument deducation）机制。</p>
<h3 id="traits编程技巧">Traits编程技巧<a hidden class="anchor" aria-hidden="true" href="#traits编程技巧">#</a></h3>
<pre tabindex="0"><code>src/my_iter.cc
</code></pre><p>func() 的回返型􏰄必须加上关键词 typename，关键词 typename 的用意在告诉编译器说这是一个类型􏰄。</p>
<h4 id="partial-specialization偏特化的意义">Partial Specialization（偏特化）的意义<a hidden class="anchor" aria-hidden="true" href="#partial-specialization偏特化的意义">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">*&gt;</span> { ... }; 
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">iterator_traits</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> T<span style="color:#f92672">*&gt;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 当迭代器是个pointer-to-const
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 萃取出来的类型应该是 T 而非 const T
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">typedef</span> value_type;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> I<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typename</span> iterator_traits<span style="color:#f92672">&lt;</span>I<span style="color:#f92672">&gt;::</span>value_type
</span></span><span style="display:flex;"><span>func(I ite) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>ite;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>根据经验，最常用到的迭代器相应型􏰄有五种：value type, difference type, pointer,
reference,iterator catagoly。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// stl_iterator.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typename</span> iterator_traits<span style="color:#f92672">&lt;</span>_Iterator<span style="color:#f92672">&gt;::</span>iterator_category,
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typename</span> iterator_traits<span style="color:#f92672">&lt;</span>_Iterator<span style="color:#f92672">&gt;::</span>value_type,
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typename</span> iterator_traits<span style="color:#f92672">&lt;</span>_Iterator<span style="color:#f92672">&gt;::</span>difference_type,
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typename</span> iterator_traits<span style="color:#f92672">&lt;</span>_Iterator<span style="color:#f92672">&gt;::</span>pointer,
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typename</span> iterator_traits<span style="color:#f92672">&lt;</span>_Iterator<span style="color:#f92672">&gt;::</span>reference
</span></span></code></pre></div><p><strong>value_type</strong></p>
<p>指迭代器所指对象的类型。</p>
<p><strong>difference_type</strong></p>
<p>表示两个迭代器之间的距离。因此，它可以用来表示一个容器的最大容量，因为对于连续空间的容器而言，头尾之间的距离就是其最大容量。</p>
<p><strong>reference</strong></p>
<p>C++ 的函数如果要传回左值，都是以 by reference 的方式进行。</p>
<p><strong>pointer</strong></p>
<p>能够传回一个 pointer，指向迭代器所指之物。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span>Item<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>ptr; }
</span></span><span style="display:flex;"><span>Item<span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">-&gt;</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> ptr; }
</span></span></code></pre></div><p><code>Item&amp;</code> 便是 reference type ， <code>Item*</code> 是 pointer type。</p>
<p><strong>iterator_category</strong></p>
<p>迭代器的分类：</p>
<ul>
<li>Input Iterator：这种迭代器所指对象，不允许外界改变</li>
<li>Output Iterator：只能写（write only）</li>
<li>Forward Iterator：读写动作</li>
<li>Bidirectional Iterator：可双向移动</li>
<li>Random Access Iterator：涵盖所有算术能力</li>
</ul>
<p><img loading="lazy" src="./20190304/3-2.png" alt=""  />
</p>
<h3 id="iterator-源码">iterator 源码<a hidden class="anchor" aria-hidden="true" href="#iterator-源码">#</a></h3>
<pre tabindex="0"><code>iterator
stl_iterator.h
stl_iterator_base_funcs.h
stl_iterator_base_types.h
stl_raw_storage_iter.h
stream_iterator.h
streambuf_iterator.h
</code></pre><h2 id="序列式容器sequence-containers">序列式容器（sequence containers）<a hidden class="anchor" aria-hidden="true" href="#序列式容器sequence-containers">#</a></h2>
<p><img loading="lazy" src="./20190304/4-1.png" alt=""  />
</p>
<p>容器是大多数人对 STL 的第一印象。</p>
<p><strong>序列式容器</strong>，其中的元素都可序（ordered），但􏰅未排序（sorted）。C++ 语言本􏰁身提供了一个序列式容器 array，STL 另外再提供 vector, list, deque, stack, queue, priority-queue 等等序列式容器。其中 stack 和 queue 由是将 deque 改头换面而成，技术上被归类为一种适配器（adapter）。</p>
<h3 id="vector">vector<a hidden class="anchor" aria-hidden="true" href="#vector">#</a></h3>
<p>vector 的数据安排以及操作方式，与 array 非常像似。它们之间的差别在于：</p>
<ul>
<li>
<p>array 是静态空间，扩容和缩容操作首先配置一块新空间，然后将元素从旧空间一一搬往新空间，然后再把原来的空间释还给系统。</p>
</li>
<li>
<p>vector 是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// stl_vector.h
</span></span></span></code></pre></div><p><img loading="lazy" src="./20190304/4-2.png" alt=""  />
</p>
<h4 id="vector的迭代器">vector的迭代器<a hidden class="anchor" aria-hidden="true" href="#vector的迭代器">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> __gnu_cxx<span style="color:#f92672">::</span>__normal_iterator<span style="color:#f92672">&lt;</span>pointer, vector_type<span style="color:#f92672">&gt;</span> iterator;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> __gnu_cxx<span style="color:#f92672">::</span>__normal_iterator<span style="color:#f92672">&lt;</span>const_pointer, vector_type<span style="color:#f92672">&gt;</span> const_iterator;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>reverse_iterator<span style="color:#f92672">&lt;</span>const_iterator<span style="color:#f92672">&gt;</span>  const_reverse_iterator;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>reverse_iterator<span style="color:#f92672">&lt;</span>iterator<span style="color:#f92672">&gt;</span>		 reverse_iterator;
</span></span></code></pre></div><p>vector 支持随机存取，提供的是 Random Access Iterators。</p>
<h4 id="vector的数据结构">vector的数据结构<a hidden class="anchor" aria-hidden="true" href="#vector的数据结构">#</a></h4>
<p>vector 所采用的数据结构非常简单：线性连续空间。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_Vector_impl</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> _Tp_alloc_type
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	_Tp<span style="color:#f92672">*</span>           _M_start;					<span style="color:#75715e">// 表示目前使用空间的头
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	_Tp<span style="color:#f92672">*</span>           _M_finish;					<span style="color:#75715e">// 表示目前使用空间的尾
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	_Tp<span style="color:#f92672">*</span>           _M_end_of_storage;	<span style="color:#75715e">// 表示目前可用空间的尾
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><p>vector 实际配置的大小可能比客端需求量更大一些，以备将来可能的扩充。</p>
<p>size 表示元素的个数，capacity 表示 vector 的容量。当增加新元素时，size 增加，当 size 超过容量（capacity）的时候，vector 的容量会增加两倍。如果两倍容量仍不足，就扩张至足够大的容量。</p>
<p>例如下面的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>vector;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> vec;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    vec.push_back(i);
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;capacity=%d, size=%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, vec.capacity(), vec.size());
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>// 运行结果
</span></span><span style="display:flex;"><span>capacity<span style="color:#f92672">=</span>1, size<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>capacity<span style="color:#f92672">=</span>2, size<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>capacity<span style="color:#f92672">=</span>4, size<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>capacity<span style="color:#f92672">=</span>4, size<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>capacity<span style="color:#f92672">=</span>8, size<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>capacity<span style="color:#f92672">=</span>8, size<span style="color:#f92672">=</span><span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span>capacity<span style="color:#f92672">=</span>8, size<span style="color:#f92672">=</span><span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span>capacity<span style="color:#f92672">=</span>8, size<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>capacity<span style="color:#f92672">=</span>16, size<span style="color:#f92672">=</span><span style="color:#ae81ff">9</span>
</span></span><span style="display:flex;"><span>capacity<span style="color:#f92672">=</span>16, size<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>
</span></span></code></pre></div><h4 id="vector的构造与内存管理constructorpush_back">vector的构造与内存管理constructor,push_back<a hidden class="anchor" aria-hidden="true" href="#vector的构造与内存管理constructorpush_back">#</a></h4>
<p>vector 提供许多 constructors，其中一个允许我们指定空间大小及初值:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>vector(size_type n, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> value) {
</span></span><span style="display:flex;"><span>  fill_initialize(n, value);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当我们以 push_back() 将新元素安插于 vector 尾端，该函式首先检查是否还有备用空间？如果有就直接在备用空间上建构元素，并调整迭代器 finish，使 vector 变大。如果没有备用空间了，就扩充空间（重新分配、搬移数据、释放原空间）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">// stl_bvector.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_M_insert_aux</span>(iterator __position, <span style="color:#66d9ef">bool</span> __x) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 检查是否还有备用空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish._M_p <span style="color:#f92672">!=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_end_of_storage)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 构造一个新元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	  std<span style="color:#f92672">::</span>copy_backward(__position, <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish, 
</span></span><span style="display:flex;"><span>			     <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	  <span style="color:#f92672">*</span>__position <span style="color:#f92672">=</span> __x;
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// 调整 finish 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	  <span style="color:#f92672">++</span><span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果原大小不为 0，则配置原大小的两倍
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	  <span style="color:#66d9ef">const</span> size_type __len <span style="color:#f92672">=</span> size() <span style="color:#f92672">?</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> size()
</span></span><span style="display:flex;"><span>	                                 <span style="color:#f92672">:</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>size_type<span style="color:#f92672">&gt;</span>(_S_word_bit);
</span></span><span style="display:flex;"><span>	  _Bit_type <span style="color:#f92672">*</span> __q <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_allocate(__len);
</span></span><span style="display:flex;"><span>	  iterator __i <span style="color:#f92672">=</span> _M_copy_aligned(begin(), __position,
</span></span><span style="display:flex;"><span>					 iterator(__q, <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>	  <span style="color:#f92672">*</span>__i<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> __x;
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>copy(__position, end(), __i);
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_deallocate();
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_end_of_storage <span style="color:#f92672">=</span> (__q <span style="color:#f92672">+</span> ((__len
</span></span><span style="display:flex;"><span>						     <span style="color:#f92672">+</span> <span style="color:#66d9ef">int</span>(_S_word_bit) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>						    <span style="color:#f92672">/</span> <span style="color:#66d9ef">int</span>(_S_word_bit)));
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_start <span style="color:#f92672">=</span> iterator(__q, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>所谓动态增加大小，并不是在原空间之后接续新空间（因为无法保证原空间之后尚有可供插入的空间），而是以原大小的两倍另外分配一块空间，然后将原内容拷贝过来，然后才开始在原内容之后插入新元素，并释放原空间。</p>
<h4 id="vector的元素操作pop_backeraseclearinsert">vector的元素操作pop_back,erase,clear,insert<a hidden class="anchor" aria-hidden="true" href="#vector的元素操作pop_backeraseclearinsert">#</a></h4>
<p><strong>pop_back</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// stl_bvector.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将尾部元素拿掉，并调整大小(finish减小)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pop_back</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">--</span><span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>size_type <span style="color:#a6e22e">size</span>() <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> size_type(end() <span style="color:#f92672">-</span> begin()); 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>iterator <span style="color:#a6e22e">end</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish; 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>erase</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">// stl_bvector.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 清除[first, finish]中的所有元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用后面的元素覆盖要删除的区间，然后修改 finish 指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>iterator <span style="color:#a6e22e">erase</span>(iterator __first, iterator __last) 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  _M_erase_at_end(std<span style="color:#f92672">::</span>copy(__last, end(), __first));
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> __first;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_M_erase_at_end</span>(iterator __pos)
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish <span style="color:#f92672">=</span> __pos;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 清除某个位置上的元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>iterator <span style="color:#a6e22e">erase</span>(iterator __position)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (__position <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">!=</span> end())
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>copy(__position <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, end(), __position);
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">--</span><span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> __position;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>clear</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// stl_bvector.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 清除所有元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">clear</span>()
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>	_M_erase_at_end(begin());
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_M_erase_at_end</span>(iterator __pos)
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish <span style="color:#f92672">=</span> __pos;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>insert</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_M_insert_aux</span>(iterator __position, <span style="color:#66d9ef">bool</span> __x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish._M_p <span style="color:#f92672">!=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_end_of_storage)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 元素后移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		std<span style="color:#f92672">::</span>copy_backward(__position, <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish, 
</span></span><span style="display:flex;"><span>			     							<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	  <span style="color:#75715e">// /从安插点开始填入新值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">*</span>__position <span style="color:#f92672">=</span> __x;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 修改 finish 指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	  <span style="color:#f92672">++</span><span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 申请 2 倍的空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="list">list<a hidden class="anchor" aria-hidden="true" href="#list">#</a></h3>
<p>list 每次插入或删除一个元素，就立即分配或释放一个元素空间。list 对于空间的运用有绝对的精准，一点也不浪费。对于任何位置的元素插入或元素删除，list 永远是常数时间。可以这么理解：vector 对应数组，list 对应链表。</p>
<h4 id="list的节点node">list的节点Node<a hidden class="anchor" aria-hidden="true" href="#list的节点node">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// stl_list.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_List_node_base</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  _List_node_base<span style="color:#f92672">*</span> _M_next;   <span style="color:#75715e">///&lt; Self-explanatory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  _List_node_base<span style="color:#f92672">*</span> _M_prev;   <span style="color:#75715e">///&lt; Self-explanatory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// @if maint An actual node in the %list.  @endif
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> _Tp<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_List_node</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> _List_node_base
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  _Tp _M_data;                <span style="color:#75715e">///&lt; User&#39;s data.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><h4 id="list的迭代器">list的迭代器<a hidden class="anchor" aria-hidden="true" href="#list的迭代器">#</a></h4>
<p>STL 的 list 是一个双向链表（double linked-list），迭代器必须具备前移、后移的能力。所以 list 提供的是 Bidirectional Iterators。</p>
<p>list 的一个重要性质：插入（insert）、连接（splice）不会造成原有的 list 迭代器失效。这在 vector 中是不成立的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// stl_list.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> _Tp<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_List_iterator</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">typedef</span> _List_iterator<span style="color:#f92672">&lt;</span>_Tp<span style="color:#f92672">&gt;</span>                _Self;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">typedef</span> _List_node<span style="color:#f92672">&lt;</span>_Tp<span style="color:#f92672">&gt;</span>                    _Node;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">typedef</span> ptrdiff_t                          difference_type;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>bidirectional_iterator_tag    iterator_category;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">typedef</span> _Tp                                value_type;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">typedef</span> _Tp<span style="color:#f92672">*</span>                               pointer;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">typedef</span> _Tp<span style="color:#f92672">&amp;</span>                               reference;
</span></span><span style="display:flex;"><span>      
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 对于迭代器的取值，取的是节点的 data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>reference <span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span>() <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>_Node<span style="color:#f92672">*&gt;</span>(_M_node)<span style="color:#f92672">-&gt;</span>_M_data;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 迭代器的成员存取
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>pointer <span style="color:#66d9ef">operator</span><span style="color:#f92672">-&gt;</span>() <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>_Node<span style="color:#f92672">*&gt;</span>(_M_node)<span style="color:#f92672">-&gt;</span>_M_data;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 跌打器加1，就是前进一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>_Self<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  _M_node <span style="color:#f92672">=</span> _M_node<span style="color:#f92672">-&gt;</span>_M_next;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 迭代器减1，就是后退一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>_Self<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">--</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  _M_node <span style="color:#f92672">=</span> _M_node<span style="color:#f92672">-&gt;</span>_M_prev;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>};	<span style="color:#75715e">// struct _List_iterator
</span></span></span></code></pre></div><h4 id="list的数据结构">list的数据结构<a hidden class="anchor" aria-hidden="true" href="#list的数据结构">#</a></h4>
<p>list 是一个双向的循环链表。</p>
<p><img loading="lazy" src="./20190304/4-3.png" alt=""  />
</p>
<p><code>_Node</code> 可以转换为迭代器类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Note that pointers-to-_Node&#39;s can be ctor-converted to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// iterator types.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">typedef</span> _List_node<span style="color:#f92672">&lt;</span>_Tp<span style="color:#f92672">&gt;</span>				 _Node;
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// 取头节点的数值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>reference <span style="color:#a6e22e">front</span>()
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>begin();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="list的构造与内存管理constructor-push_baskinsert">list的构造与内存管理：constructor, push_bask,insert<a hidden class="anchor" aria-hidden="true" href="#list的构造与内存管理constructor-push_baskinsert">#</a></h4>
<p>list 使用 Alloc 做为空间分配器，并另外定义了 <code>_Node_alloc_type</code> ，为的是更方便的以节点大小为分配单位。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">// 使用 Alloc 做为空间分配器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> _Tp, <span style="color:#66d9ef">typename</span> _Alloc<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 每次配置一个节点大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">typename</span> _Alloc<span style="color:#f92672">::</span><span style="color:#66d9ef">template</span> rebind<span style="color:#f92672">&lt;</span>_List_node<span style="color:#f92672">&lt;</span>_Tp<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;::</span>other
</span></span><span style="display:flex;"><span>        _Node_alloc_type;
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// 分配一个节点并返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>_List_node<span style="color:#f92672">&lt;</span>_Tp<span style="color:#f92672">&gt;*</span> _M_get_node()
</span></span><span style="display:flex;"><span>{ <span style="color:#66d9ef">return</span> _M_impl._Node_alloc_type<span style="color:#f92672">::</span>allocate(<span style="color:#ae81ff">1</span>); }
</span></span><span style="display:flex;"><span>      
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 释放一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_M_put_node</span>(_List_node<span style="color:#f92672">&lt;</span>_Tp<span style="color:#f92672">&gt;*</span> __p)
</span></span><span style="display:flex;"><span>{ _M_impl._Node_alloc_type<span style="color:#f92672">::</span>deallocate(__p, <span style="color:#ae81ff">1</span>); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 分配一个节点，并赋初值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>_Node<span style="color:#f92672">*</span> <span style="color:#a6e22e">_M_create_node</span>(<span style="color:#66d9ef">const</span> value_type<span style="color:#f92672">&amp;</span> __x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	_Node<span style="color:#f92672">*</span> __p <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_get_node();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>    _M_get_Tp_allocator().construct(<span style="color:#f92672">&amp;</span>__p<span style="color:#f92672">-&gt;</span>_M_data, __x);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">catch</span>(...)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    _M_put_node(__p);
</span></span><span style="display:flex;"><span>    __throw_exception_again;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> __p;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 删除一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Erases element at position given.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_M_erase</span>(iterator __position)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  __position._M_node<span style="color:#f92672">-&gt;</span>unhook();
</span></span><span style="display:flex;"><span>  _Node<span style="color:#f92672">*</span> __n <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>_Node<span style="color:#f92672">*&gt;</span>(__position._M_node);
</span></span><span style="display:flex;"><span>  _M_get_Tp_allocator().destroy(<span style="color:#f92672">&amp;</span>__n<span style="color:#f92672">-&gt;</span>_M_data);
</span></span><span style="display:flex;"><span>  _M_put_node(__n);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// new_allocator.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">destroy</span>(pointer __p) { __p<span style="color:#f92672">-&gt;~</span>_Tp(); }
</span></span></code></pre></div><p>list 提供了很多 constructors：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">explicit</span> <span style="color:#a6e22e">list</span>(<span style="color:#66d9ef">const</span> allocator_type<span style="color:#f92672">&amp;</span> __a <span style="color:#f92672">=</span> allocator_type())
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">:</span> _Base(__a) { }
</span></span></code></pre></div><p>push_back() 将新元素插入到 list 的尾部：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">push_back</span>(<span style="color:#66d9ef">const</span> value_type<span style="color:#f92672">&amp;</span> __x)
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_insert(end(), __x);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Inserts new element at position given and with value given.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_M_insert</span>(iterator __position, <span style="color:#66d9ef">const</span> value_type<span style="color:#f92672">&amp;</span> __x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  _Node<span style="color:#f92672">*</span> __tmp <span style="color:#f92672">=</span> _M_create_node(__x);
</span></span><span style="display:flex;"><span>  __tmp<span style="color:#f92672">-&gt;</span>hook(__position._M_node);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在 list 内的某处插入新节点，首先必须确定安插位置。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(iterator __position, size_type __n, <span style="color:#66d9ef">const</span> value_type<span style="color:#f92672">&amp;</span> __x)
</span></span><span style="display:flex;"><span>{  
</span></span><span style="display:flex;"><span>  list __tmp(__n, __x, _M_get_Node_allocator());
</span></span><span style="display:flex;"><span>  splice(__position, __tmp);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// example: 在ls链表头插入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ls.insert(ls.begin(), <span style="color:#ae81ff">6</span>);
</span></span></code></pre></div><p>list 不像 vector 那样有可能在空间不足时做重新分配、数据迁移的动作，所以插入前的所有迭代器在插入动作之后都仍然有效。</p>
<h4 id="list的元素操作">list的元素操作<a hidden class="anchor" aria-hidden="true" href="#list的元素操作">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">// 插入一个节点，作为头节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">push_front</span>(<span style="color:#66d9ef">const</span> value_type<span style="color:#f92672">&amp;</span> __x)
</span></span><span style="display:flex;"><span>  { <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_insert(begin(), __x); }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 插入一个节点，作为尾节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">push_back</span>(<span style="color:#66d9ef">const</span> value_type<span style="color:#f92672">&amp;</span> __x)
</span></span><span style="display:flex;"><span>  { <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_insert(end(), __x); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 删除迭代器 position 所指节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>iterator <span style="color:#a6e22e">erase</span>(iterator __position);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 删除头节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pop_front</span>()
</span></span><span style="display:flex;"><span>  { <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_erase(begin()); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 删除尾节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pop_back</span>()
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_erase(iterator(<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_node._M_prev)); }
</span></span></code></pre></div><p>list 内部提供一个所谓的迁移动作（transfer），将某连续范围的元素迁移到某个特定位置之前。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// Moves the elements from [first,last) before position.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_M_transfer</span>(iterator __position, iterator __first, iterator __last)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	__position._M_node<span style="color:#f92672">-&gt;</span>transfer(__first._M_node, __last._M_node);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>list 公开提供的是所谓的接合动作（splice）：将某连续范围的元素从一个 list 搬移到另一个（或同一个）list 的某个定点。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">// 将x连接到position所指的位置之前
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">splice</span>(iterator __position, list<span style="color:#f92672">&amp;</span> __x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>__x.empty())
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    _M_check_equal_allocators(__x);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_transfer(__position, __x.begin(), __x.end());
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将i所指元素连接到__position所指位置之前
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">splice</span>(iterator __position, list<span style="color:#f92672">&amp;</span> __x, iterator __i)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	iterator __j <span style="color:#f92672">=</span> __i;
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">++</span>__j;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (__position <span style="color:#f92672">==</span> __i <span style="color:#f92672">||</span> __position <span style="color:#f92672">==</span> __j)
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>__x)
</span></span><span style="display:flex;"><span>	  _M_check_equal_allocators(__x);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_transfer(__position, __i, __j);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将 [first,last) 内的所有元素连接接于 position所指位置之前。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">splice</span>(iterator __position, list<span style="color:#f92672">&amp;</span> __x, iterator __first, iterator __last)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (__first <span style="color:#f92672">!=</span> __last)
</span></span><span style="display:flex;"><span>	  {
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>__x)
</span></span><span style="display:flex;"><span>	      _M_check_equal_allocators(__x);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_transfer(__position, __first, __last);
</span></span><span style="display:flex;"><span>	  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>有了 transfer()，merge()、reverse() 和 sort() 的源码并不难实现。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> _Tp, <span style="color:#66d9ef">typename</span> _Alloc<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> list<span style="color:#f92672">&lt;</span>_Tp, _Alloc<span style="color:#f92672">&gt;::</span>
</span></span><span style="display:flex;"><span>merge(list<span style="color:#f92672">&amp;</span> __x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// _GLIBCXX_RESOLVE_LIB_DEFECTS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 300. list::merge() specification incomplete
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>__x)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	  _M_check_equal_allocators(__x); 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	  iterator __first1 <span style="color:#f92672">=</span> begin();
</span></span><span style="display:flex;"><span>	  iterator __last1 <span style="color:#f92672">=</span> end();
</span></span><span style="display:flex;"><span>	  iterator __first2 <span style="color:#f92672">=</span> __x.begin();
</span></span><span style="display:flex;"><span>	  iterator __last2 <span style="color:#f92672">=</span> __x.end();
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">while</span> (__first1 <span style="color:#f92672">!=</span> __last1 <span style="color:#f92672">&amp;&amp;</span> __first2 <span style="color:#f92672">!=</span> __last2)
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>__first2 <span style="color:#f92672">&lt;</span> <span style="color:#f92672">*</span>__first1)
</span></span><span style="display:flex;"><span>	      {
</span></span><span style="display:flex;"><span>          iterator __next <span style="color:#f92672">=</span> __first2;
</span></span><span style="display:flex;"><span>          _M_transfer(__first1, __first2, <span style="color:#f92672">++</span>__next);
</span></span><span style="display:flex;"><span>          __first2 <span style="color:#f92672">=</span> __next;
</span></span><span style="display:flex;"><span>	      }
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>	      <span style="color:#f92672">++</span>__first1;
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">if</span> (__first2 <span style="color:#f92672">!=</span> __last2)
</span></span><span style="display:flex;"><span>	    _M_transfer(__last1, __first2, __last2);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="deque">deque<a hidden class="anchor" aria-hidden="true" href="#deque">#</a></h3>
<p>vector 是单向开口的连续线性空间，也就是说，只能从一端进行插入。deque 则是一种双向开口的连续线性空间，可以在头尾两端分别􏰁做元素的插入和删除动作。</p>
<p><img loading="lazy" src="./20190304/4-4.png" alt=""  />
</p>
<p>deque 在两端插入或删除，时间复杂度都是常数级的。不同于 vector，如果在头插入，需要将所有元素后移，时间复杂度是线性级别的。</p>
<p>应尽可能选择使用 vector 而非 deque。对 deque 进行的排序动作，为了最高效率，可将 deque 先完整复制到一个 vector 身上，将 vector 排序后（利用 STL sort 算法），再复制回 deque。</p>
<h4 id="deque的中控件">deque的中控件<a hidden class="anchor" aria-hidden="true" href="#deque的中控件">#</a></h4>
<p>deque 由一段一段的定量连续空间构成。一旦有必要在 deque 的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个 deque 的头端或尾端。</p>
<p>为了维护整体连续的假象，数据结构的设计及迭代器前进后退等动作都颇为繁琐。deque 的代码量远比 vector 或 list 多得多。</p>
<p>deque 采用一块 map（一小块连续的控件），其中的每个元素指向另一段较大的连续线性空间，成为缓冲区。缓冲区是 deque 的存储空间主体。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 元素的指针的指针	
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">typedef</span> pointer<span style="color:#f92672">*</span>	_Map_pointer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 每个node都指向一块缓冲区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>_Map_pointer _M_node;
</span></span></code></pre></div><p><img loading="lazy" src="./20190304/4-5.png" alt=""  />
</p>
<h4 id="deque的迭代器">deque的迭代器<a hidden class="anchor" aria-hidden="true" href="#deque的迭代器">#</a></h4>
<p>deque 是分段连续空间。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> _Tp, <span style="color:#66d9ef">typename</span> _Ref, <span style="color:#66d9ef">typename</span> _Ptr<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_Deque_iterator</span>	<span style="color:#75715e">// 未继承 std::iterator
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">typedef</span> _Deque_iterator<span style="color:#f92672">&lt;</span>_Tp, _Tp<span style="color:#f92672">&amp;</span>, _Tp<span style="color:#f92672">*&gt;</span>             iterator;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">typedef</span> _Deque_iterator<span style="color:#f92672">&lt;</span>_Tp, <span style="color:#66d9ef">const</span> _Tp<span style="color:#f92672">&amp;</span>, <span style="color:#66d9ef">const</span> _Tp<span style="color:#f92672">*&gt;</span> const_iterator;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">static</span> size_t <span style="color:#a6e22e">_S_buffer_size</span>()
</span></span><span style="display:flex;"><span>      { <span style="color:#66d9ef">return</span> __deque_buf_size(<span style="color:#66d9ef">sizeof</span>(_Tp)); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 自行撰写 5 个必要的跌打器类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>random_access_iterator_tag iterator_category; <span style="color:#75715e">//(1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">typedef</span> _Tp                             value_type;	<span style="color:#75715e">// (2)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">typedef</span> _Ptr                            pointer;	<span style="color:#75715e">// (3)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">typedef</span> _Ref                            reference;	<span style="color:#75715e">// (4)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">typedef</span> size_t                          size_type;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">typedef</span> ptrdiff_t                       difference_type;	<span style="color:#75715e">// (5)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">typedef</span> _Tp<span style="color:#f92672">**</span>                           _Map_pointer;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">typedef</span> _Deque_iterator                 _Self;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      _Tp<span style="color:#f92672">*</span> _M_cur;	<span style="color:#75715e">// 此迭代器所指缓冲区的当前（current）元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      _Tp<span style="color:#f92672">*</span> _M_first;	<span style="color:#75715e">// 指向缓冲区的头
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      _Tp<span style="color:#f92672">*</span> _M_last;	<span style="color:#75715e">// 指向缓冲区的尾
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      _Map_pointer _M_node;	<span style="color:#75715e">// 指向控制中心
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      };
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">// 决定缓冲区大小的函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> size_t <span style="color:#a6e22e">_S_buffer_size</span>()
</span></span><span style="display:flex;"><span>      { <span style="color:#66d9ef">return</span> __deque_buf_size(<span style="color:#66d9ef">sizeof</span>(_Tp)); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 如果 sz(元素大小，sizeof(value_type))小于 512，传回 512/sz， 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 如果 sz 不小于 512，传回 1。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">inline</span> size_t
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">__deque_buf_size</span>(size_t __size)
</span></span><span style="display:flex;"><span>  { <span style="color:#66d9ef">return</span> __size <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">512</span> <span style="color:#f92672">?</span> size_t(<span style="color:#ae81ff">512</span> <span style="color:#f92672">/</span> __size) <span style="color:#f92672">:</span> size_t(<span style="color:#ae81ff">1</span>); }
</span></span></code></pre></div><p><img loading="lazy" src="./20190304/4-6.png" alt=""  />
</p>
<p>begin() 和 end() 所传回的两个迭代器如下图：</p>
<p><img loading="lazy" src="./20190304/4-7.png" alt=""  />
</p>
<p>一旦行进时遇到缓冲区边缘，视前进或后退而定，可能需要调用 set_node() 切换缓冲区。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_M_set_node</span>(_Map_pointer __new_node)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	_M_node <span style="color:#f92672">=</span> __new_node;
</span></span><span style="display:flex;"><span>	_M_first <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>__new_node;
</span></span><span style="display:flex;"><span>	_M_last <span style="color:#f92672">=</span> _M_first <span style="color:#f92672">+</span> difference_type(_S_buffer_size());
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>      
</span></span><span style="display:flex;"><span>_Self<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">++</span>_M_cur;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (_M_cur <span style="color:#f92672">==</span> _M_last)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>  		<span style="color:#75715e">// 切换下一个节点（即下一个缓冲区）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	    _M_set_node(_M_node <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	    _M_cur <span style="color:#f92672">=</span> _M_first;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="deque的数据结构">deque的数据结构<a hidden class="anchor" aria-hidden="true" href="#deque的数据结构">#</a></h4>
<p>deque 维护 start, finish 两个迭代器，分􏰁指向第一缓冲区的第一个元素和最后缓冲区的最后一个元素（的下一位置）。</p>
<pre tabindex="0"><code> struct _Deque_impl
      : public _Tp_alloc_type
{
	_Tp** _M_map;		// 指向map，一块连续的空间
	size_t _M_map_size;	// map内的节点数
	iterator _M_start;	// 第一个节点
	iterator _M_finish;	// 最后一个节点

	_Deque_impl(const _Tp_alloc_type&amp; __a)
	: _Tp_alloc_type(__a), _M_map(0), _M_map_size(0),
	  _M_start(), _M_finish()
	{ }
};
</code></pre><p>有了以上的结构，很多操作便可以轻易完成：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">// iterators
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*  Returns a read/write iterator that points to the first element in the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*  %deque.  Iteration is done in ordinary element order.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span>iterator
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">begin</span>()
</span></span><span style="display:flex;"><span>{ <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_start; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*  Returns a read/write iterator that points one past the last
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*  element in the %deque.  Iteration is done in ordinary
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*  element order.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span>iterator
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">end</span>()
</span></span><span style="display:flex;"><span>{ <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish; }
</span></span></code></pre></div><h4 id="deque的构造与内存管理">deque的构造与内存管理<a hidden class="anchor" aria-hidden="true" href="#deque的构造与内存管理">#</a></h4>
<p>deque自行定义了两个专属的空间配置器:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">// 每次分配一个元素大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> _Deque_base<span style="color:#f92672">&lt;</span>_Tp, _Alloc<span style="color:#f92672">&gt;</span>           _Base;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 每次分配一个指针大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">typename</span> _Base<span style="color:#f92672">::</span>_Tp_alloc_type	 _Tp_alloc_type;
</span></span></code></pre></div><p>并提供 constructor：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">explicit</span> <span style="color:#a6e22e">deque</span>(size_type __n, <span style="color:#66d9ef">const</span> value_type<span style="color:#f92672">&amp;</span> __value <span style="color:#f92672">=</span> value_type(),
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> allocator_type<span style="color:#f92672">&amp;</span> __a <span style="color:#f92672">=</span> allocator_type())
</span></span><span style="display:flex;"><span><span style="color:#f92672">:</span> _Base(__a, __n)
</span></span><span style="display:flex;"><span>{ _M_fill_initialize(__value); }
</span></span></code></pre></div><p><code>_M_fill_initialize()</code>产生并初始化后 deque 的结构：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> _Tp, <span style="color:#66d9ef">typename</span> _Alloc<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span>    deque<span style="color:#f92672">&lt;</span>_Tp, _Alloc<span style="color:#f92672">&gt;::</span>
</span></span><span style="display:flex;"><span>    _M_fill_initialize(<span style="color:#66d9ef">const</span> value_type<span style="color:#f92672">&amp;</span> __value)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      _Map_pointer __cur;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 为每个节点的缓冲区设定初值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          <span style="color:#66d9ef">for</span> (__cur <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_start._M_node;
</span></span><span style="display:flex;"><span>	       __cur <span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish._M_node;
</span></span><span style="display:flex;"><span>	       <span style="color:#f92672">++</span>__cur)
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>__uninitialized_fill_a(<span style="color:#f92672">*</span>__cur, <span style="color:#f92672">*</span>__cur <span style="color:#f92672">+</span> _S_buffer_size(),
</span></span><span style="display:flex;"><span>					__value, _M_get_Tp_allocator());
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 最后一个节点设定不同，尾端可能有备用空间，不必设初值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          std<span style="color:#f92672">::</span>__uninitialized_fill_a(<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish._M_first,
</span></span><span style="display:flex;"><span>				      <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish._M_cur,
</span></span><span style="display:flex;"><span>				      __value, _M_get_Tp_allocator());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">catch</span>(...)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          std<span style="color:#f92672">::</span>_Destroy(<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_start, iterator(<span style="color:#f92672">*</span>__cur, __cur),
</span></span><span style="display:flex;"><span>			_M_get_Tp_allocator());
</span></span><span style="display:flex;"><span>          __throw_exception_again;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>push_back() 函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">push_back</span>(<span style="color:#66d9ef">const</span> value_type<span style="color:#f92672">&amp;</span> __x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish._M_cur
</span></span><span style="display:flex;"><span>	    <span style="color:#f92672">!=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish._M_last <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>	  {
</span></span><span style="display:flex;"><span>	  <span style="color:#75715e">// 最后缓冲区尚有一个以上的备用空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	    <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl.construct(<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish._M_cur, __x);	<span style="color:#75715e">//直接在备用空间上建构元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	    <span style="color:#f92672">++</span><span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish._M_cur;	<span style="color:#75715e">//调整最后缓冲区的使用状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	  }
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>	<span style="color:#75715e">// 最后缓冲区已无(或只剩一个)元素备用空间。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	  _M_push_back_aux(__x);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 只有当 finish.cur == finish.last – 1时才会被调用。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 即：当最后一个缓冲区只剩一个备用元素空间时才会被呼叫。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> _Tp, <span style="color:#66d9ef">typename</span> _Alloc<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> deque<span style="color:#f92672">&lt;</span>_Tp, _Alloc<span style="color:#f92672">&gt;::</span>
</span></span><span style="display:flex;"><span>    _M_push_back_aux(<span style="color:#66d9ef">const</span> value_type<span style="color:#f92672">&amp;</span> __t)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    value_type __t_copy <span style="color:#f92672">=</span> __t;
</span></span><span style="display:flex;"><span>    _M_reserve_map_at_back();	<span style="color:#75715e">// // 如果 map尾端的节点备用空间不足,则必须重换一个map
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">*</span>(<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish._M_node <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_allocate_node();	<span style="color:#75715e">//配置一个新节点(缓冲区)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl.construct(<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish._M_cur, __t_copy);	<span style="color:#75715e">//针对标的元素设值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish._M_set_node(<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish._M_node
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);	<span style="color:#75715e">//改变 finish，令其指向新节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish._M_cur <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish._M_first;	<span style="color:#75715e">//设定finish的状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">catch</span>(...)
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        _M_deallocate_node(<span style="color:#f92672">*</span>(<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish._M_node <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>        __throw_exception_again;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>push_front()</code> 函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">push_front</span>(<span style="color:#66d9ef">const</span> value_type<span style="color:#f92672">&amp;</span> __x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//第一缓冲区尚有备用空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_start._M_cur <span style="color:#f92672">!=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_start._M_first)
</span></span><span style="display:flex;"><span>	  {
</span></span><span style="display:flex;"><span>    	<span style="color:#75715e">// 直接在备用空间上建构元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	    <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl.construct(<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_start._M_cur <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, __x);
</span></span><span style="display:flex;"><span>	    <span style="color:#75715e">//调整第一缓冲区的使用状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    	<span style="color:#f92672">--</span><span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_start._M_cur;
</span></span><span style="display:flex;"><span>	  }
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 第一缓冲区已无备用空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>	  _M_push_front_aux(__x);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="deque的元素操作pop_backpop_frontcleareraseinsert">deque的元素操作pop_back,pop_front,clear,erase,insert<a hidden class="anchor" aria-hidden="true" href="#deque的元素操作pop_backpop_frontcleareraseinsert">#</a></h4>
<p>所谓 pop，是将元素拿掉。无论从 deque 的最前端或最尾端取元素，都需考虑在某种条件下，将缓冲区释放掉:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pop_front</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 第一缓冲区有一个(或更多)元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_start._M_cur
</span></span><span style="display:flex;"><span>	    <span style="color:#f92672">!=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_start._M_last <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>	  {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 将第一元素销毁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	    <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl.destroy(<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_start._M_cur);
</span></span><span style="display:flex;"><span>	  	<span style="color:#75715e">// //调整指针，相当于排除了第一元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    	<span style="color:#f92672">++</span><span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_start._M_cur;
</span></span><span style="display:flex;"><span>	  }
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 第一缓冲区仅有一个元素，进行缓冲区的释放工作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>	  _M_pop_front_aux();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//只有当 start.cur == start.last - 1 时才会被呼叫。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> _Tp, <span style="color:#66d9ef">typename</span> _Alloc<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> deque<span style="color:#f92672">&lt;</span>_Tp, _Alloc<span style="color:#f92672">&gt;::</span>
</span></span><span style="display:flex;"><span>    _M_pop_front_aux()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 将第一缓冲区的第一个元素解构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl.destroy(<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_start._M_cur);
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// //释放第一缓冲区。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      _M_deallocate_node(<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_start._M_first);
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">//调整 start的状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_start._M_set_node(<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_start._M_node <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 下一个缓冲区的第一个元素。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_start._M_cur <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_start._M_first;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>clear()</code>，用来清除整个 deque。请注意，deque 的最初状态（无任何元素时）保有一个缓冲区，因此 clear() 完成之后回复初始状态，也一样要
保留一个缓冲区:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">clear</span>()
</span></span><span style="display:flex;"><span>{ _M_erase_at_end(begin()); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Called by erase(q1, q2), resize(), clear(), _M_assign_aux,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// _M_fill_assign, operator=.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_M_erase_at_end</span>(iterator __pos)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	_M_destroy_data(__pos, end(), _M_get_Tp_allocator());
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// +1 的目的是：保留头尾缓冲区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  _M_destroy_nodes(__pos._M_node <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>			 <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish._M_node <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish <span style="color:#f92672">=</span> __pos;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>insert()</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> _Tp, <span style="color:#66d9ef">typename</span> _Alloc<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typename</span> deque<span style="color:#f92672">&lt;</span>_Tp, _Alloc<span style="color:#f92672">&gt;::</span>iterator
</span></span><span style="display:flex;"><span>deque<span style="color:#f92672">&lt;</span>_Tp, _Alloc<span style="color:#f92672">&gt;::</span>
</span></span><span style="display:flex;"><span>insert(iterator __position, <span style="color:#66d9ef">const</span> value_type<span style="color:#f92672">&amp;</span> __x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 如果插入点是 deque最前端
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (__position._M_cur <span style="color:#f92672">==</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_start._M_cur)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	  push_front(__x);
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_start;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 如果插入点是 deque最尾端
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (__position._M_cur <span style="color:#f92672">==</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish._M_cur)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	  push_back(__x);
</span></span><span style="display:flex;"><span>	  iterator __tmp <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish;
</span></span><span style="display:flex;"><span>	  <span style="color:#f92672">--</span>__tmp;
</span></span><span style="display:flex;"><span>	  <span style="color:#66d9ef">return</span> __tmp;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_M_insert_aux</span>(__position, __x);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> _Tp, <span style="color:#66d9ef">typename</span> _Alloc<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typename</span> deque<span style="color:#f92672">&lt;</span>_Tp, _Alloc<span style="color:#f92672">&gt;::</span>iterator
</span></span><span style="display:flex;"><span>    deque<span style="color:#f92672">&lt;</span>_Tp, _Alloc<span style="color:#f92672">&gt;::</span>
</span></span><span style="display:flex;"><span>    _M_insert_aux(iterator __pos, <span style="color:#66d9ef">const</span> value_type<span style="color:#f92672">&amp;</span> __x)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 安插点之前的元素个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      difference_type __index <span style="color:#f92672">=</span> __pos <span style="color:#f92672">-</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_start;
</span></span><span style="display:flex;"><span>      value_type __x_copy <span style="color:#f92672">=</span> __x; <span style="color:#75715e">// XXX copy
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// 如果安插点之前的元素个数比较少
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>size_type<span style="color:#f92672">&gt;</span>(__index) <span style="color:#f92672">&lt;</span> size() <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 在最前端加入与第一元素同值的元素。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        push_front(front());
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 以下标示记号，然后进行元素搬移...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        iterator __front1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_start;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">++</span>__front1;
</span></span><span style="display:flex;"><span>        iterator __front2 <span style="color:#f92672">=</span> __front1;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">++</span>__front2;
</span></span><span style="display:flex;"><span>        __pos <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_start <span style="color:#f92672">+</span> __index;
</span></span><span style="display:flex;"><span>        iterator __pos1 <span style="color:#f92672">=</span> __pos;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">++</span>__pos1;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 元素搬移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>copy(__front2, __pos1, __front1);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">else</span>	<span style="color:#75715e">//安插点之后的元素个数比较少
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      {
</span></span><span style="display:flex;"><span>        push_back(back());	<span style="color:#75715e">// 最尾端插入与最后元素同值的元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        iterator __back1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_finish;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">--</span>__back1;
</span></span><span style="display:flex;"><span>        iterator __back2 <span style="color:#f92672">=</span> __back1;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">--</span>__back2;
</span></span><span style="display:flex;"><span>        __pos <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_impl._M_start <span style="color:#f92672">+</span> __index;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 元素搬移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>copy_backward(__pos, __back2, __back1);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 在插入点设定新值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#f92672">*</span>__pos <span style="color:#f92672">=</span> __x_copy;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> __pos;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h3 id="stack">stack<a hidden class="anchor" aria-hidden="true" href="#stack">#</a></h3>
<p>stack 是一种先进后出（First In Last Out，FILO）的数据结构，它只有一个出口。stack 允许新增元素、移除元素、取得最顶端元素。但除了最顶端外，没有任何其它方法可以存取 stack 的其它元素。</p>
<p><img loading="lazy" src="./20190304/4-8.png" alt=""  />
</p>
<h4 id="stack定义式完整列表">stack定义式完整列表<a hidden class="anchor" aria-hidden="true" href="#stack定义式完整列表">#</a></h4>
<p>以某种既有容器做为底部结构，将其接口改变，使符合「先进后出」的特性，形
成一个 stack，是很容易做到的。deque 是双向开口的数据结构，若以 deque 为
底部结构并封闭其头端开口，便轻而易举地形成了一个 stack。</p>
<pre tabindex="0"><code>template&lt;typename _Tp, typename _Sequence = deque&lt;_Tp&gt; &gt;
class stack
{
 protected:
      //  底层容器
    _Sequence c;
};
</code></pre><p><img loading="lazy" src="./20190304/4-9.png" alt=""  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">/** Returns true if the %stack is empty. */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">empty</span>() <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>{ <span style="color:#66d9ef">return</span> c.empty(); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**  Returns the number of elements in the %stack.  */</span>
</span></span><span style="display:flex;"><span>size_type <span style="color:#a6e22e">size</span>() <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>{ <span style="color:#66d9ef">return</span> c.size(); }
</span></span></code></pre></div><h4 id="stack没有迭代器">stack没有迭代器<a hidden class="anchor" aria-hidden="true" href="#stack没有迭代器">#</a></h4>
<p>stack 所有元素的进出都必须符合「先进后出」的条件，只有 stack 顶端的元素，才有机会被外界取用。 不提供迭代器。</p>
<h4 id="以list为stack的底层容器">以list为stack的底层容器<a hidden class="anchor" aria-hidden="true" href="#以list为stack的底层容器">#</a></h4>
<p>除了deque 之外，list 也是双向开口的数据结构。上述 stack 源码中使用的底层容器的函数有 empty, size, back, push_back, pop_back，list 都具备。</p>
<h3 id="queue">queue<a hidden class="anchor" aria-hidden="true" href="#queue">#</a></h3>
<p>queue 是一种先进先出（First In First Out，FIFO）的数据结构，它有两个出口。</p>
<p><img loading="lazy" src="./20190304/4-10.png" alt=""  />
</p>
<p>queue 只能从一端插入，另一端删除。除了最底端可以加入、最顶端可以取出，没有任何其它方法可以存取 queue 的其它元素。</p>
<h4 id="queue定义式完整列表">queue定义式完整列表<a hidden class="anchor" aria-hidden="true" href="#queue定义式完整列表">#</a></h4>
<p>SGI STL 便以 deque 做为预设情况下的 queue 底层结构。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> _Tp, <span style="color:#66d9ef">typename</span> _Sequence <span style="color:#f92672">=</span> deque<span style="color:#f92672">&lt;</span>_Tp<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">queue</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 底层容器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  _Sequence c;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p><img loading="lazy" src="./20190304/4-11.png" alt=""  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">push</span>(<span style="color:#66d9ef">const</span> value_type<span style="color:#f92672">&amp;</span> __x)
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>	c.push_back(__x);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>      
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pop</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  __glibcxx_requires_nonempty();
</span></span><span style="display:flex;"><span>  c.pop_front();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="queue没有迭代器">queue没有迭代器<a hidden class="anchor" aria-hidden="true" href="#queue没有迭代器">#</a></h4>
<p>queue 所有元素的进出都必须符合「先进先出」的条件，只有 queue 顶端的元素，才有机会被外界取用。</p>
<h4 id="以list做为queue的底层容器">以list做为queue的底层容器<a hidden class="anchor" aria-hidden="true" href="#以list做为queue的底层容器">#</a></h4>
<p>除了deque 之外，list 也是双向开口的数据结构。上述 queue 源码中使用的底层容器的函数有 empty, size, back, push_back, pop_back，list 都具备。</p>
<h3 id="heap">heap<a hidden class="anchor" aria-hidden="true" href="#heap">#</a></h3>
<p>heap 并不归属于 STL 容器组件，它的背后是 priority queue（优先队列）。priority queue 允许使用者以任何次序将任何元素推入容器内，但取出时一定是从优先权最高的元素开始取。</p>
<p>使用 list 做为 priority queue 的底层机制，元素插入动作可享常数时间。但是要找到 list 中的极值，却需要对整个 list 进行线性扫描。</p>
<p>使用 binary search tree 做为 priority queue 的底层机制，元素的插入和极值的取得就有 O(logN) 的表现。但是这需要确保输入数据的随机性。</p>
<p>priority queue 的复杂度，最好介于 queue 和 binary search tree之间，才算适得其所。binary heap 便是这种条件下的适当候选人。</p>
<p>binary heap 是一颗完全二叉树。当完全二叉树中的某个节点位于 array 的 i 处，其左子节点必位于 array 的 2i+1 处，其右子节点必位于 array 的 2i+2 处（这里的索引从 0 开始）。</p>
<p><img loading="lazy" src="./20190304/4-12.png" alt=""  />
</p>
<p>其父节点必定是 ⌊(i - 1)/2⌋。</p>
<p>根据元素排列方式，heap 可分为 max-heap 和 min-heap 两种，max-heap 的最大值在根节点，min-heap 的最小值在根节点。</p>
<h4 id="heap算法">heap算法<a hidden class="anchor" aria-hidden="true" href="#heap算法">#</a></h4>
<p><strong>push_heap</strong></p>
<p>为了保持完全二叉树的性质，应该将新元素插入在底层 vector 的 end() 处。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> _RandomAccessIterator<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span>push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  std<span style="color:#f92672">::</span>__push_heap(__first, _DistanceType((__last <span style="color:#f92672">-</span> __first) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span>  _DistanceType(<span style="color:#ae81ff">0</span>), _ValueType(<span style="color:#f92672">*</span>(__last <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> _RandomAccessIterator, <span style="color:#66d9ef">typename</span> _Compare<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span>push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
</span></span><span style="display:flex;"><span>    _Compare __comp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 值必置于底部 -&gt; 容器的最尾端
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>__push_heap(__first, _DistanceType((__last <span style="color:#f92672">-</span> __first) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span> 	_DistanceType(<span style="color:#ae81ff">0</span>), _ValueType(<span style="color:#f92672">*</span>(__last <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)), __comp);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 不允许指定，（大小比较标准）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> _RandomAccessIterator, <span style="color:#66d9ef">typename</span> _Distance, <span style="color:#66d9ef">typename</span> _Tp,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typename</span> _Compare<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span>    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
</span></span><span style="display:flex;"><span>		_Distance __topIndex, _Tp __value, _Compare __comp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    _Distance __parent <span style="color:#f92672">=</span> (__holeIndex <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;	<span style="color:#75715e">// 父节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (__holeIndex <span style="color:#f92672">&gt;</span> __topIndex	
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">&amp;&amp;</span> __comp(<span style="color:#f92672">*</span>(__first <span style="color:#f92672">+</span> __parent), __value))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 当尚􏰃到达顶端，且父节点小于新值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#f92672">*</span>(__first <span style="color:#f92672">+</span> __holeIndex) <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(__first <span style="color:#f92672">+</span> __parent);
</span></span><span style="display:flex;"><span>      __holeIndex <span style="color:#f92672">=</span> __parent;
</span></span><span style="display:flex;"><span>      __parent <span style="color:#f92672">=</span> (__holeIndex <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(__first <span style="color:#f92672">+</span> __holeIndex) <span style="color:#f92672">=</span> __value;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>pop_heap</strong></p>
<p>pop 动作取走根节点，必须将最下一层最右边的叶节点拿来填补跟节点的位置，并维护堆的性质。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> _RandomAccessIterator<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span>    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      std<span style="color:#f92672">::</span>__pop_heap(__first, __last <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, __last <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>          _ValueType(<span style="color:#f92672">*</span>(__last <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> _RandomAccessIterator, <span style="color:#66d9ef">typename</span> _Compare<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span>    pop_heap(_RandomAccessIterator __first,
</span></span><span style="display:flex;"><span>       _RandomAccessIterator __last, _Compare __comp)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      std<span style="color:#f92672">::</span>__pop_heap(__first, __last <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, __last <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>          _ValueType(<span style="color:#f92672">*</span>(__last <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)), __comp);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> _RandomAccessIterator, <span style="color:#66d9ef">typename</span> _Tp<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span>    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
</span></span><span style="display:flex;"><span>         _RandomAccessIterator __result, _Tp __value)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">typename</span> iterator_traits<span style="color:#f92672">&lt;</span>_RandomAccessIterator<span style="color:#f92672">&gt;::</span>difference_type
</span></span><span style="display:flex;"><span>  _Distance;
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 设定尾值为首值，于是尾值即为欲求结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#75715e">// 可由客端稍后再以底层容器之 pop_back() 取出尾值。  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#f92672">*</span>__result <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>__first;
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 以上欲重新调整 heap
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      std<span style="color:#f92672">::</span>__adjust_heap(__first, _Distance(<span style="color:#ae81ff">0</span>), _Distance(__last <span style="color:#f92672">-</span> __first),
</span></span><span style="display:flex;"><span>       __value);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> _RandomAccessIterator, <span style="color:#66d9ef">typename</span> _Distance,
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">typename</span> _Tp, <span style="color:#66d9ef">typename</span> _Compare<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span>    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
</span></span><span style="display:flex;"><span>      _Distance __len, _Tp __value, _Compare __comp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">const</span> _Distance __topIndex <span style="color:#f92672">=</span> __holeIndex;
</span></span><span style="display:flex;"><span>      _Distance __secondChild <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> __holeIndex <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>;  <span style="color:#75715e">// 右节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">while</span> (__secondChild <span style="color:#f92672">&lt;</span> __len)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (__comp(<span style="color:#f92672">*</span>(__first <span style="color:#f92672">+</span> __secondChild),
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">*</span>(__first <span style="color:#f92672">+</span> (__secondChild <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>))))
</span></span><span style="display:flex;"><span>      __secondChild<span style="color:#f92672">--</span>;  <span style="color:#75715e">// 减1后为左节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// secondChild代表较大子节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">*</span>(__first <span style="color:#f92672">+</span> __holeIndex) <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(__first <span style="color:#f92672">+</span> __secondChild);
</span></span><span style="display:flex;"><span>    __holeIndex <span style="color:#f92672">=</span> __secondChild;
</span></span><span style="display:flex;"><span>    __secondChild <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> (__secondChild <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 如果没有右节点，只有左子节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (__secondChild <span style="color:#f92672">==</span> __len)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>(__first <span style="color:#f92672">+</span> __holeIndex) <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(__first <span style="color:#f92672">+</span> (__secondChild <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>    __holeIndex <span style="color:#f92672">=</span> __secondChild <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>      std<span style="color:#f92672">::</span>__push_heap(__first, __holeIndex, __topIndex, __value, __comp);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>pop_heap 之后，最大元素只是被置放于底部容器的最尾端，尚􏰃被取走。如果要取其值，可使用底部容器（vector）所提供的 back() 操作函数。如果要移除它，可使用底部容器（vector）所提供的 pop_back() 操作函式。</p>
<p><strong>sort_heap</strong>
排序过后，原来的 heap 就不再是个合法的 heap 了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">// 每执行一次 pop_heap()，极值(在 STL heap 中为极大值)即被放在尾端。 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 扣除尾端再执行一次 pop_heap()，次极值又被放在新尾端。一直下去，最后即得
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 排序结果。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> _RandomAccessIterator<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span>    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">while</span> (__last <span style="color:#f92672">-</span> __first <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>      std<span style="color:#f92672">::</span>pop_heap(__first, _RandomAccessIterator(__last<span style="color:#f92672">--</span>));
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p><strong>make_heap</strong>
这个算法用来将一段现有的数据转化为一个 heap。</p>
<pre tabindex="0"><code>template&lt;typename _RandomAccessIterator&gt;
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      // 如果长度为 0或 1，不必重新排列。
      if (__last - __first &lt; 2)
        return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
  {
    std::__adjust_heap(__first, __parent, __len,
           _ValueType(*(__first + __parent)));
    if (__parent == 0)
      return;
    __parent--;
  }
    }
</code></pre><h4 id="heap也没有迭代器">heap也没有迭代器<a hidden class="anchor" aria-hidden="true" href="#heap也没有迭代器">#</a></h4>
<h3 id="priority_queue">priority_queue<a hidden class="anchor" aria-hidden="true" href="#priority_queue">#</a></h3>
<p>priority_queue 是一个拥有权值观念的 queue，它允许加入新元素、移除旧元素，审视元素值等功能。由于这是一个 queue，所以只允许在底端加入元素，并从顶端取出元素，除此之外􏰁无其它存取元素的途径。</p>
<pre tabindex="0"><code>template&lt;typename _Tp, typename _Sequence = vector&lt;_Tp&gt;,
     typename _Compare  = less&lt;typename _Sequence::value_type&gt; &gt;
    class priority_queue
    {
    protected:
      // vector为底层容器
      _Sequence  c;
      _Compare   comp;  // 元素大小的比较标准

      // ....
    };
</code></pre><p><img loading="lazy" src="./20190304/4-13.png" alt=""  />
</p>
<h4 id="priority_queue也没有迭代器">priority_queue也没有迭代器<a hidden class="anchor" aria-hidden="true" href="#priority_queue也没有迭代器">#</a></h4>
<h3 id="slist">slist<a hidden class="anchor" aria-hidden="true" href="#slist">#</a></h3>
<p>STL list 是个双向链表（double linked list）。SGI STL 另提供了一个单向串行（single linked list），名为slist。
slist 和 list 的主要差􏰁在于，前者的迭代器属于单向的 Forward  Iterator，后者的迭代器属于双向的 Bidirectional Iterator。
slist 和 list 共同具有的一个相同特色是，它们的插入（insert）、移除（erase）、接合（splice）等动作并不会造成原有的迭代器失效。</p>
<p>基于效率考虑，slist 不提供 push_back()，只提供 push_front()。</p>
<h4 id="slist的节点">slist的节点<a hidden class="anchor" aria-hidden="true" href="#slist的节点">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">// 单向串行的节点基􏰀结构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_Slist_node_base</span>
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    _Slist_node_base<span style="color:#f92672">*</span> _M_next;
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 单向串行的节点结构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_Tp</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_Slist_node</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> _Slist_node_base
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    _Tp _M_data;
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//已知某一节点，安插新节点于其后。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">inline</span> _Slist_node_base<span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">__slist_make_link</span>(_Slist_node_base<span style="color:#f92672">*</span> __prev_node,
</span></span><span style="display:flex;"><span>        _Slist_node_base<span style="color:#f92672">*</span> __new_node)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    __new_node<span style="color:#f92672">-&gt;</span>_M_next <span style="color:#f92672">=</span> __prev_node<span style="color:#f92672">-&gt;</span>_M_next;
</span></span><span style="display:flex;"><span>    __prev_node<span style="color:#f92672">-&gt;</span>_M_next <span style="color:#f92672">=</span> __new_node;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> __new_node;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 反转一个链表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">inline</span> _Slist_node_base<span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">__slist_reverse</span>(_Slist_node_base<span style="color:#f92672">*</span> __node)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    _Slist_node_base<span style="color:#f92672">*</span> __result <span style="color:#f92672">=</span> __node;
</span></span><span style="display:flex;"><span>    __node <span style="color:#f92672">=</span> __node<span style="color:#f92672">-&gt;</span>_M_next;
</span></span><span style="display:flex;"><span>    __result<span style="color:#f92672">-&gt;</span>_M_next <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(__node)
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>  _Slist_node_base<span style="color:#f92672">*</span> __next <span style="color:#f92672">=</span> __node<span style="color:#f92672">-&gt;</span>_M_next;
</span></span><span style="display:flex;"><span>  __node<span style="color:#f92672">-&gt;</span>_M_next <span style="color:#f92672">=</span> __result;
</span></span><span style="display:flex;"><span>  __result <span style="color:#f92672">=</span> __node;
</span></span><span style="display:flex;"><span>  __node <span style="color:#f92672">=</span> __next;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> __result;
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><h3 id="slist的迭代器">slist的迭代器<a hidden class="anchor" aria-hidden="true" href="#slist的迭代器">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#75715e">//单向串行的迭代器基􏰀结构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_Slist_iterator_base</span>
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typedef</span> size_t                    size_type;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typedef</span> ptrdiff_t                 difference_type;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>forward_iterator_tag iterator_category;  <span style="color:#75715e">// 单向
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>     _Slist_node_base<span style="color:#f92672">*</span> _M_node; <span style="color:#75715e">//指向节点基􏰀结构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_M_incr</span>()  <span style="color:#75715e">// // 前进一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    { _M_node <span style="color:#f92672">=</span> _M_node<span style="color:#f92672">-&gt;</span>_M_next; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ....
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//单向串行的迭代器结构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_Tp</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_Ref</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_Ptr</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_Slist_iterator</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> _Slist_iterator_base
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">typedef</span> _Slist_iterator<span style="color:#f92672">&lt;</span>_Tp, _Tp<span style="color:#f92672">&amp;</span>, _Tp<span style="color:#f92672">*&gt;</span>             iterator;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">typedef</span> _Slist_iterator<span style="color:#f92672">&lt;</span>_Tp, <span style="color:#66d9ef">const</span> _Tp<span style="color:#f92672">&amp;</span>, <span style="color:#66d9ef">const</span> _Tp<span style="color:#f92672">*&gt;</span> const_iterator;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">typedef</span> _Slist_iterator<span style="color:#f92672">&lt;</span>_Tp, _Ref, _Ptr<span style="color:#f92672">&gt;</span>             _Self;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      _Self<span style="color:#f92672">&amp;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>()
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        _M_incr();  <span style="color:#75715e">// //前进一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      _Self
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>(<span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        _Self __tmp <span style="color:#f92672">=</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>        _M_incr();  <span style="color:#75715e">// //前进一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> __tmp;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    };
</span></span></code></pre></div><h4 id="slist的数据结构">slist的数据结构<a hidden class="anchor" aria-hidden="true" href="#slist的数据结构">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_Tp</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">_Alloc</span> <span style="color:#f92672">=</span> allocator<span style="color:#f92672">&lt;</span>_Tp<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">slist</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">private</span> _Slist_base<span style="color:#f92672">&lt;</span>_Tp,_Alloc<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// concept requirements
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">typedef</span> _Slist_base<span style="color:#f92672">&lt;</span>_Tp,_Alloc<span style="color:#f92672">&gt;</span> _Base;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">typedef</span> _Tp               value_type;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">typedef</span> value_type<span style="color:#f92672">*</span>       pointer;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">const</span> value_type<span style="color:#f92672">*</span> const_pointer;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">typedef</span> value_type<span style="color:#f92672">&amp;</span>       reference;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">const</span> value_type<span style="color:#f92672">&amp;</span> const_reference;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">typedef</span> size_t            size_type;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">typedef</span> ptrdiff_t         difference_type;
</span></span><span style="display:flex;"><span>      
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">typedef</span> _Slist_iterator<span style="color:#f92672">&lt;</span>_Tp, _Tp<span style="color:#f92672">&amp;</span>, _Tp<span style="color:#f92672">*&gt;</span>             iterator;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">typedef</span> _Slist_iterator<span style="color:#f92672">&lt;</span>_Tp, <span style="color:#66d9ef">const</span> _Tp<span style="color:#f92672">&amp;</span>, <span style="color:#66d9ef">const</span> _Tp<span style="color:#f92672">*&gt;</span> const_iterator;
</span></span><span style="display:flex;"><span>      
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">typename</span> _Base<span style="color:#f92672">::</span>allocator_type allocator_type;
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">typedef</span> _Slist_node<span style="color:#f92672">&lt;</span>_Tp<span style="color:#f92672">&gt;</span>      _Node;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">typedef</span> _Slist_node_base      _Node_base;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">typedef</span> _Slist_iterator_base  _Iterator_base;
</span></span><span style="display:flex;"><span>      
</span></span><span style="display:flex;"><span>      _Node<span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">_M_create_node</span>(<span style="color:#66d9ef">const</span> value_type<span style="color:#f92672">&amp;</span> __x)
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 配置空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      _Node<span style="color:#f92672">*</span> __node <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_get_node();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 构造元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        get_allocator().construct(<span style="color:#f92672">&amp;</span>__node<span style="color:#f92672">-&gt;</span>_M_data, __x);
</span></span><span style="display:flex;"><span>        __node<span style="color:#f92672">-&gt;</span>_M_next <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">catch</span>(...)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_put_node(__node);
</span></span><span style="display:flex;"><span>      __throw_exception_again;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> __node;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  iterator
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">begin</span>()
</span></span><span style="display:flex;"><span>      { <span style="color:#66d9ef">return</span> iterator((_Node<span style="color:#f92672">*</span>)<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_head._M_next); }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  iterator
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">end</span>()
</span></span><span style="display:flex;"><span>      { <span style="color:#66d9ef">return</span> iterator(<span style="color:#ae81ff">0</span>); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">empty</span>() <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>      { <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_head._M_next <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">swap</span>(slist<span style="color:#f92672">&amp;</span> __x)
</span></span><span style="display:flex;"><span>      { std<span style="color:#f92672">::</span>swap(<span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_head._M_next, __x._M_head._M_next); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 取头部元素    
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  reference
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">front</span>()
</span></span><span style="display:flex;"><span>      { <span style="color:#66d9ef">return</span> ((_Node<span style="color:#f92672">*</span>) <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_head._M_next)<span style="color:#f92672">-&gt;</span>_M_data; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 删除头部元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">pop_front</span>()
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>  _Node<span style="color:#f92672">*</span> __node <span style="color:#f92672">=</span> (_Node<span style="color:#f92672">*</span>) <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_head._M_next;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_head._M_next <span style="color:#f92672">=</span> __node<span style="color:#f92672">-&gt;</span>_M_next;
</span></span><span style="display:flex;"><span>  get_allocator().destroy(<span style="color:#f92672">&amp;</span>__node<span style="color:#f92672">-&gt;</span>_M_data);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">this</span><span style="color:#f92672">-&gt;</span>_M_put_node(__node);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://landodo.github.io/tags/c&#43;&#43;/">C&#43;&#43;</a></li>
      <li><a href="http://landodo.github.io/tags/stl/">STL</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://landodo.github.io/posts/20210804-clustering-method/">
    <span class="title">« Prev Page</span>
    <br>
    <span>节点聚类问题的总结和思考</span>
  </a>
  <a class="next" href="http://landodo.github.io/posts/20220320-hyperseg/">
    <span class="title">Next Page »</span>
    <br>
    <span>HyperSeg: Patch-wise Hypernetwork for Real-time Semantic Segmentation</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>Landon</span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>

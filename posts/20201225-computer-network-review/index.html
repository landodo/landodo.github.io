<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">


<meta name="robots" content="index, follow">
<title>计算机网络基础（3） | Notes</title>
<meta name="keywords" content="计算机网络" />
<meta name="description" content="计算机网络复习 OSI (Open Systems Interconnection) 参考模型和 TCP/IP 模型 TCP/IP 四层模型的代表协议： 网络接口层（Link Layer）：ARP 协议（IP addr &mdash;ARP&mdash;&gt;MAC addr） IP 网络层（Int">
<meta name="author" content="">
<link rel="canonical" href="http://landodo.github.io/posts/20201225-computer-network-review/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<link rel="preload" href="./logo.png" as="image">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://landodo.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://landodo.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://landodo.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://landodo.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="http://landodo.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="计算机网络基础（3）" />
<meta property="og:description" content="计算机网络复习 OSI (Open Systems Interconnection) 参考模型和 TCP/IP 模型 TCP/IP 四层模型的代表协议： 网络接口层（Link Layer）：ARP 协议（IP addr &mdash;ARP&mdash;&gt;MAC addr） IP 网络层（Int" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://landodo.github.io/posts/20201225-computer-network-review/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-25T10:17:29&#43;08:00" />
<meta property="article:modified_time" content="2020-12-25T10:17:29&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="计算机网络基础（3）"/>
<meta name="twitter:description" content="计算机网络复习 OSI (Open Systems Interconnection) 参考模型和 TCP/IP 模型 TCP/IP 四层模型的代表协议： 网络接口层（Link Layer）：ARP 协议（IP addr &mdash;ARP&mdash;&gt;MAC addr） IP 网络层（Int"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://landodo.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "计算机网络基础（3）",
      "item": "http://landodo.github.io/posts/20201225-computer-network-review/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "计算机网络基础（3）",
  "name": "计算机网络基础（3）",
  "description": "计算机网络复习 OSI (Open Systems Interconnection) 参考模型和 TCP/IP 模型 TCP/IP 四层模型的代表协议： 网络接口层（Link Layer）：ARP 协议（IP addr \u0026mdash;ARP\u0026mdash;\u0026gt;MAC addr） IP 网络层（Int",
  "keywords": [
    "计算机网络"
  ],
  "articleBody": "计算机网络复习 OSI (Open Systems Interconnection) 参考模型和 TCP/IP 模型\nTCP/IP 四层模型的代表协议：\n 网络接口层（Link Layer）：ARP 协议（IP addr —ARP—MAC addr） IP 网络层（Internet Layer）：IP、ICMP、IGMP 等协议。 传输层（Transport Layer）：TCP 和 UDP 协议 应用层（Application Layer）：HTTP、SMTP、DNS、FTP、SSH、DHCP、Telnet  数据传输单位：\n 物理层：比特 数据链路层：帧 网络层：数据报 传输层：报文段（TCP）、用户数据报（UDP）  TCP/IP 四层结构有什么优缺点？\n优点：\n TCP/IP 在设计之初就考虑到了多种异构网的互联问题，并将 IP 作为一个单独的重要层次。  缺点：\n 它在服务、接口与协议的区别上不清楚。 TCP/IP 的主机－网络层本身并不是实际的一层，它定义了网络层与数据链路层的接口。物理层与数据链路层的划分是必要和合理的，一个好的参考模型应该将它们区分开来，而 TCP/IP 参考模型却没有做到这点。  OSI 七层模型的优缺点？\n优点：\n OSI 参考模型的最大贡献就是精确定义了三个主要概念：服务、接口和协议。这与现代的面向对象程序设计思想非常吻合。 OSI 参考模型产生在协议发明之前，通用性较好。  2. TCP 的拥塞控制 2.1 慢启动 慢启动机制\n 初始窗口 initial cwnd，初始值设置为 3 或 10 慢启动门限值 ssthresh，初始值设置为 1 « 31 每收到 ACK，窗口值加 1  慢启动并不慢\n 在没有丢包情况下，经过 log2(target_cwnd/initial_cwnd) 个 RTT 长到目标窗口大小  Initialization: cwnd TCP 锯齿状窗口行为。\n2.2 快速重传  一般情况下，先发送的数据包应该先到达。如果后发送的数据包先被确认，可推测先发送的数据包丢失。 如果一个数据包后面的三个数据包都被确认，而该数据包还未收到确认，则认定该数据包丢失，并重传该数据包。 数据包通常都是连续发送的。快速重传通常可以在 1 个 RTT 内重传数据丢包。  为什么需要等 3 个后续数据包的确认?\n 防止因数据包乱序引起的误重传 在无线网络、多路径传输中会有部分乱序 假设网络中乱序长度不大于 3 个数据包 通过 D-SACK 机制 (Duplicate SACK) 识别一个数据包没有丢失，而是乱序。  一般来说，快速重传可以恢复长流中的大部分丢包。\n3.2 超时重传   重传后丢包，即同一数据包被丢弃两次后，只能等待超时重传。\n  通过超时来判断数据包丢失\n  定时器至少大于一个 RTT (Round Trip Time)\n  定时器必须能够适应 RTT 变化，定时器必须同时反映出 RTT 大小和 RTT 变化\n  Linux 中最小值为 200ms\n  3.3 避免拥塞 流控（Flow Control）：\n 为了防止快发送方给慢接收方发数据造成接收崩溃。注意与拥塞控制的区别。 发送方和接收方各自维护一个窗口大小  两种拥塞控制思路：\n 端到端的拥塞控制：端设备通过丢包、延迟变化 等推测网络拥塞状况。TCP 使用端到端的拥塞控制策略。 网络辅助的拥塞控制：网络设备对端设备提供反馈。  TCP 的拥塞控制算法基础：\n (1) TCP 端设备遇到丢包时，认为网络拥塞，减慢发送速率（发送速率（窗口大小）减半） (2) TCP 端设备定期通过增大发送速率来探测更多可用带宽（每个 RTT，窗口值增加一个数据包大小）  ✅ 3.4 几种拥塞控制的方法总结 RFC 2581 定义了进行拥塞控制的四种算法，即慢开始（slow-start）、拥塞避免（congestion avoidance）、快重传（fast retransmit）和快恢复（fast recovery）。\n（1）慢开始（slow-start）和拥塞避免（congestion avoidance）\n（2）快重传（fast retransmit）和快恢复（fast recovery）\n发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段 M3，而不必继续等待为 M3 设置的重传计时器到期。\n快恢复（fast recovery）门限 ssthresh = cwnd / 2; cwnd = ssthresh; \n4. 简述从输入网页网址到获得相关网页内容的步骤 （1）浏览器根据 DNS（Domain Name System，域名系统）服务器返回的真实地址请求网页，DNS 主要负责把对人类友好的网址转换为对机器友好的 IP 地址。\n（2）浏览器请求计算机建立对这个 IP 地址的标准 Web 端口（80）或标准安全 Web 端口（443）的TCP（Transmission Control Protocol，传输控制协议）连接。\n（3）当浏览器连接到 Web 服务器之后会请求网站，这一步就要用到 HTTP（或 HTTPS） 了。\n（4）服务器会根据请求的 URL 响应相关内容。\n（5）Web 浏览器负责处理返回的响应（HTML/CSS/JS）。\n（6）Web 浏览器请求自己需要的额外资源。\n（7）浏览器在获取了足够的关键资源后，开始在屏幕上渲染页面。\n（8）在页面刚刚显示在屏幕上之后，浏览器会在后台继续下载其他资源，并在处理完它们之后更新页面。\n（9）当页面完全被加载后，浏览器会停止显示加载图标（在多数浏览器上都位于地址栏旁边），然后触发 OnLoad JavaScript 事件。根据这个事件，JavaScript 就知道可以执行某些操作了。\n（10）此时，页面已经完全加载了，但浏览器并不会停止发送请求。网页只包含静态内容的时代早就过去了。\n5. HTTPS 过程   显然易见的是，非对称加密在性能上不如对称加密，两者各有其优缺点。HTTPS 就是将两者的优点结合起来。更具体的说就是，公钥私钥主要用于传输对称密钥，而真正的双方大量数据量的通信都是通过对称密钥进行的。\n  数字证书用来解决公钥的合法性问题。\n  非对称加密需要通过证书（Certificate）和权威机构 CA（Certificate Authority）来验证公钥的合法性。CA 通过层层授信背书的方式，从而确保了非对称加密模式的正常运转。\n  我在 HTTPS 服务器的实验中，在数据传输之前，客户端和服务器会获取对方的证书，检查证书的基本信息（因为证书是自己签名的，没有权威 CA，因此不进行证书层层校验，直接认定是一个合法的证书），之后商量好对称密钥，使用对称密钥进行数据传输。\n6. 简述区块链的技术原理和应用 6.1 技术原理简述 区块链（Blockchain）是一种创新的分布式交易验证和数据共享技术，也被称为分布式共享总账（Distributed Shared Ledger）。\n区块（block）保存：\n （1）业务记录集合（以 hash link 的方式） （2）前序块的哈希值（数字摘要） （3）(1+2) 的哈希值（数字摘要）。  每个记录中有发起者的数字签名，保证操作的不可伪造性和不可抵赖性。\n链（chain），就是逻辑上由 “ (2) 前序块的哈希值” 串联起来的链条，保证不可删除、时序性和不可篡改特性。\n后块为所有的前块背书，起到 “联保” 作用， 这样的数据结构即使是最初发布数据的人也不能改动他自己的数据了。\n区块链解决的核心和本质问题是：无可信中心机构时，如何在信息不对称、不确定的环境下，建立满足活动赖以发生、发展的“信任”生态体系，即 “拜占庭容错”或者“两军问题”。\n6.2 应用简述 区块链技术的适用场景：\n 多方参与 缺乏统一信任主体 存在价值流通或信任传递  工信部《中国区块链技术和应用发展白皮书》\n区块链热点应用案例：\n 供应链金融，现有问题：造假风险、企业信息孤岛、履约风险高。 支付、清算、结算，现有问题：造假资金滞后、成本高昂。 跨境贸易，现有问题：数据缺乏共享，形成数据孤岛；参与方之间信任缺失；流程协同低效；中心平台透明度低，依赖性强。 政务现代化，现有问题：信息资源不共享、不开放、成本高昂；⺴络安全存在隐患；多方介入，效率低下；缺乏法律制度保障。 人力资源，现有问题：学历造假、履历造假、绩效管理不透明。 司法版权 电子发票 医疗健康 智能制造 小额数字资产 国家法定数字货币  7. 数据中心网络，数据级流和流量级流的优劣势  流量模式不固定，分钟级别的变化都可能很大  ECMP, “Equal Cost Multi Path”：流级别的负载均衡\n 使用 HASH （source-addr, dst-addr, source-port, dst-port） 优势：一条流的数据包在相同的 path 上 不足：elephants flows  VL2：Virtual Layer 2（整个网络看做是一个二层交换机）基于实际数据出发，使用已有的技术，实现可 扩展、敏捷的数据中心网络。\n 优点：每条流随机选择中间交换机（Intermediate）转发，随机性解决不稳定性 缺点：（1）目录服务器的引入是否会成为瓶颈? （2）为了实现 VLB，所有链路、所有交换机一直在线，能耗高。  8. NDN 的体系结构 NDN 的体系结构改变的是现行网络体系结构的哪些部分？为什么 NDN 很难部署？\nNDN：Named Data Networking\n目前互联网面临的问题：大量的补丁使得 IP 网络系统越来越复杂，而且可能阻碍业务的创新。\n 流量激增 移动性支持 安全/管理控制问题  新的体系结构，核心：naming，addressing。\nNDN 解决三个关联问题。\n接收方的数据传输：一个 Interest 对应一个 Data\n带状态、hop-by-hop 数据传输：Data 沿着 Interest 的反向路径传输回去\nNDN 安全：\n 完整性、正确性：IP 的管道安全—NDN 的内容安全 DoS 攻击：(1) 一个 Interest 对应一个 Data，不会引起 Data 的 flooding。(2) 相同的 Interest 在可以在 Pending Interest Table 中屏蔽。  NDN 缺点导致难以部署：\n 带状态的网络，将使得网络设备的实现和维护复杂 名字是不定长的，路由表查找困难 交互式应用支持问题 路由表规模非常庞大  9. BBR 测量链路瓶颈 BBR：在 TCP 的演进历史中，在不降低吞吐率的前提下减少延迟。是 TCP 拥塞控制算法优化。\nBBR (Bottleneck Bandwidth and RTT) 设计目标：在不降低吞吐率的同时，减少网络延迟。\n (1) 每次收到 ACK 后，更新对 Max Throughput 和 Min RTT 的估计 (2) 通过控制发送数据量来探测 Max Throughput 和 Min RTT  BBR 测量链路瓶颈带宽和 RTT，为什么不能同时测量？如何请求测量这两个值？\nBBR 的基本理念就是尽量估算 $RTT_{prop}$ 和 Bottleneck BW 这两个参数。\n$$cwnd=2\\times BDP=2\\times (RTT_{prop} + btlBW)$$\n$RTT_{prop}$ 和 Bottleneck BW 是两个重新审视拥塞控制的参数:\n $RTT_{prop}$：round-trip propagation time btlBW： bottleneck bandwidth  类比水管的话，$RTT_{prop}$ 就是水管的长度，btlBW 就是水管的宽度。\n我也不知道怎么测？\n10. 内容分发 CDN 访问局部性：\n 80-20 准则、zipf 定律：20% 的内容吸引 80% 的访问（10-20% 的内容产生 80% 的访问）  CDN: Content Delivery Network：把内容拷⻉到不同地域的多台服务器， 减轻服务器负载，提升用户感知的质量。\nCDN 主动发布内容：原始服务器发布内容到 CDN 分发节点，CDN 主动复制内容到其他服务器。\nCDN 核心问题：选择哪个服务器？\n CDN 提供商持续监测服务器的负载、性能 距离客户端近的服务器  静态配置：通过 HTTP Redirect 实现\n 比如：来自北京的请求，都重定向到北京的服务器  DNS 回顾：\nAkamai：全球最大的 CDN。Akamai 工作原理：\n NS-based mapping  $MAP_t = \\sum_{internet} \\times \\sum_{Akamai}\\times Domain \\times LDNS \\rightarrow IPs$\n end-user mapping  $EUMAP_{t} = \\sum_{internet} \\times \\sum_{Akaamai} \\times Domain \\times Client \\rightarrow IPs $\nCDN 面临的挑战：\n 网络层面：(1) CDN服务器所在⺴络与其他⺴络的互联问题；(2) 内容传输效率问题 应用层面：(1) 内容放置问题(地域)：内容复制到哪些服务器上? (2) 存储问题:多大的存储空间?  11. 路由器/交换机 Buffer 队列 数据包队列是网络中间设备中最关键的部分之一，其大小、管理策略等很大程度上影响了网络性能。\n队列应该设为多大？\n $BufferSize=\\bar{RTT} \\times C$: $\\bar{RTT}$ 为端到端平均链路延迟，C 为瓶颈链路带宽。  队列大小与队列管理策略、传输控制策略等关系密切。\n队列大小决定传输速率，传输控制策略影响了队列行为。\n队列过大：$BufferSize  \\bar{RTT} \\times C$，当窗口减半时，队列不能清空数据包，因此数据包的延迟会增加。\n队列过小：$BufferSize 闲状态。\n数据中心网络的交换机队列：队列相对过小 (under-buffered) 造成了 TCP-Incast 问题。\n广域网的路由转发设备队列：队列过大 (over-buffered) 造成了 BufferBloat 问题。\n解决 BufferBloat 问题：\n 减小队列大小 改进传输控制策略 改进队列管理策略 Tail Drop (尾部丢弃) RED (Random Early Detection)：主动 (proactively) 丢包 (Early Detection)，概率性丢包。 CoDel (Controlling Delay)：控制数据包在队列中的时间(延迟)，而不是队列长度。  数据包队列总结：\n 队列是网络设备中的关键部分，其大小、管理策略影响了网络性能。 队列设置过大或过小都容易产生问题。过小 – TCP Incast 问题，过大 – BufferBloat 问题 队列大小、队列管理策略、传输控制策略之间的关系非常紧密。  12. FIB 计算算法、IPv4 Trie 树、IPv6 的优化方法 FIB (Forwarding Information Base)，路由器转发表。转发表中存储的是网络号与下一跳地址的映射关系\n21.1 IP报文转发规则 路由器收到 IP 报文后，获取目的地址 D，按照如下规则进行转发:\n（1）如果 D 与路由器在同一网络内，直接交付给主机 D，并返回;\n（2）在转发表中进行最长前缀匹配，如果匹配成功，则将 IP 报文转发到该下一跳网关，并返回;\n（3）如果转发表中有默认路由，则将IP报文转发给默认路由器，并返回;\n（4）报告转发分组出错（ICMP，目的网络不可达）。\n12.2 Trie 高速查找、快速更新和可拓展的虚拟路由器 IP 查找方法！\n每增加一个 trie 树，节点大小只增加 1 比特。存储 14 个 IPv4 核心路由器 FIB，trie 树大小仅为 10MB。\n决策树算法的缺点：在决策树算法中，90% 的内存占用来自规则的复制。\n12.3 IPv6  IPv6 地址长度为 128 位。IPv6 地址用十六进制表示，分为 8 段，中间用 : 隔开：  2001:0410:0000:0001:0000:0000:0000:45ff  每段的起始 0 可以省略，连续全零的段可用 :: 表示（只能出现一次）  2001:410:0:1:0:0:0:45ff, 2001:410:0:1::45ff  不同起始码对应不同类型 IPv6 地址，例如 ::ffff/96 表示与 IPv4 兼容的地址  128 为的 IPv6 的优势：更容易进行层次化（Hierarchical）编址。\nMAC 地址转换为 IPv6 地址：\n 先将 MAC 地址转换为 EUI-64 标识（64 位全球唯一标识 (Extended Unique Identifier)） IPv6 网络前缀 (64 位) + EUI-64 地址  IPv4 地址到 IPv6 地址的映射：\n 前缀为 ::ffff/96 是保留一小部分地址与 IPv4 兼容的 数据报在这两类节点之间转发时，需要进行地址的转换 NAT-PT (Protocol Translator）  IPv6 取消了 ARP 协议。通过邻居请求报文（NS）和邻居通告报文（NA）来解析三层地址对应的链路层地址。\n",
  "wordCount" : "5376",
  "inLanguage": "en",
  "datePublished": "2020-12-25T10:17:29+08:00",
  "dateModified": "2020-12-25T10:17:29+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://landodo.github.io/posts/20201225-computer-network-review/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes",
    "logo": {
      "@type": "ImageObject",
      "url": "http://landodo.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://landodo.github.io/" accesskey="h" title="Notes (Alt + H)">
                <img src="http://landodo.github.io/logo.png" alt="logo" aria-label="logo"
                    height="30">Notes</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="http://landodo.github.io/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://landodo.github.io/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="http://landodo.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://landodo.github.io/tags" title="Tag">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="http://landodo.github.io/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="http://landodo.github.io/cs-zoo" title="CS ZOO">
                    <span>CS ZOO</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://landodo.github.io/">Home</a>&nbsp;»&nbsp;<a href="http://landodo.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      计算机网络基础（3）
    </h1>
    <div class="post-meta"><span title='2020-12-25 10:17:29 +0800 CST'>December 25, 2020</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;5376 words

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e5%a4%8d%e4%b9%a0" aria-label="计算机网络复习">计算机网络复习</a><ul>
                        
                <li>
                    <a href="#2-tcp-%e7%9a%84%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6" aria-label="2. TCP 的拥塞控制">2. TCP 的拥塞控制</a><ul>
                        
                <li>
                    <a href="#21-%e6%85%a2%e5%90%af%e5%8a%a8" aria-label="2.1 慢启动">2.1 慢启动</a></li>
                <li>
                    <a href="#22-%e5%bf%ab%e9%80%9f%e9%87%8d%e4%bc%a0" aria-label="2.2 快速重传">2.2 快速重传</a></li>
                <li>
                    <a href="#32-%e8%b6%85%e6%97%b6%e9%87%8d%e4%bc%a0" aria-label="3.2 超时重传">3.2 超时重传</a></li>
                <li>
                    <a href="#33-%e9%81%bf%e5%85%8d%e6%8b%a5%e5%a1%9e" aria-label="3.3 避免拥塞">3.3 避免拥塞</a></li>
                <li>
                    <a href="#-34-%e5%87%a0%e7%a7%8d%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6%e7%9a%84%e6%96%b9%e6%b3%95%e6%80%bb%e7%bb%93" aria-label="✅ 3.4 几种拥塞控制的方法总结">✅ 3.4 几种拥塞控制的方法总结</a></li></ul>
                </li>
                <li>
                    <a href="#4-%e7%ae%80%e8%bf%b0%e4%bb%8e%e8%be%93%e5%85%a5%e7%bd%91%e9%a1%b5%e7%bd%91%e5%9d%80%e5%88%b0%e8%8e%b7%e5%be%97%e7%9b%b8%e5%85%b3%e7%bd%91%e9%a1%b5%e5%86%85%e5%ae%b9%e7%9a%84%e6%ad%a5%e9%aa%a4" aria-label="4. 简述从输入网页网址到获得相关网页内容的步骤">4. 简述从输入网页网址到获得相关网页内容的步骤</a></li>
                <li>
                    <a href="#5-https-%e8%bf%87%e7%a8%8b" aria-label="5. HTTPS 过程">5. HTTPS 过程</a></li>
                <li>
                    <a href="#6-%e7%ae%80%e8%bf%b0%e5%8c%ba%e5%9d%97%e9%93%be%e7%9a%84%e6%8a%80%e6%9c%af%e5%8e%9f%e7%90%86%e5%92%8c%e5%ba%94%e7%94%a8" aria-label="6. 简述区块链的技术原理和应用">6. 简述区块链的技术原理和应用</a><ul>
                        
                <li>
                    <a href="#61-%e6%8a%80%e6%9c%af%e5%8e%9f%e7%90%86%e7%ae%80%e8%bf%b0" aria-label="6.1 技术原理简述">6.1 技术原理简述</a></li>
                <li>
                    <a href="#62-%e5%ba%94%e7%94%a8%e7%ae%80%e8%bf%b0" aria-label="6.2 应用简述">6.2 应用简述</a></li></ul>
                </li>
                <li>
                    <a href="#7-%e6%95%b0%e6%8d%ae%e4%b8%ad%e5%bf%83%e7%bd%91%e7%bb%9c%e6%95%b0%e6%8d%ae%e7%ba%a7%e6%b5%81%e5%92%8c%e6%b5%81%e9%87%8f%e7%ba%a7%e6%b5%81%e7%9a%84%e4%bc%98%e5%8a%a3%e5%8a%bf" aria-label="7. 数据中心网络，数据级流和流量级流的优劣势">7. 数据中心网络，数据级流和流量级流的优劣势</a></li>
                <li>
                    <a href="#8-ndn-%e7%9a%84%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84" aria-label="8. NDN 的体系结构">8. NDN 的体系结构</a></li>
                <li>
                    <a href="#9-bbr-%e6%b5%8b%e9%87%8f%e9%93%be%e8%b7%af%e7%93%b6%e9%a2%88" aria-label="9. BBR 测量链路瓶颈">9. BBR 测量链路瓶颈</a></li>
                <li>
                    <a href="#10-%e5%86%85%e5%ae%b9%e5%88%86%e5%8f%91-cdn" aria-label="10. 内容分发 CDN">10. 内容分发 CDN</a></li>
                <li>
                    <a href="#11-%e8%b7%af%e7%94%b1%e5%99%a8%e4%ba%a4%e6%8d%a2%e6%9c%ba-buffer-%e9%98%9f%e5%88%97" aria-label="11. 路由器/交换机 Buffer 队列">11. 路由器/交换机 Buffer 队列</a></li>
                <li>
                    <a href="#12-fib-%e8%ae%a1%e7%ae%97%e7%ae%97%e6%b3%95ipv4-trie-%e6%a0%91ipv6-%e7%9a%84%e4%bc%98%e5%8c%96%e6%96%b9%e6%b3%95" aria-label="12. FIB 计算算法、IPv4 Trie 树、IPv6 的优化方法">12. FIB 计算算法、IPv4 Trie 树、IPv6 的优化方法</a><ul>
                        
                <li>
                    <a href="#211-ip%e6%8a%a5%e6%96%87%e8%bd%ac%e5%8f%91%e8%a7%84%e5%88%99" aria-label="21.1 IP报文转发规则">21.1 IP报文转发规则</a></li>
                <li>
                    <a href="#122-trie" aria-label="12.2 Trie">12.2 Trie</a></li>
                <li>
                    <a href="#123-ipv6" aria-label="12.3 IPv6">12.3 IPv6</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="计算机网络复习">计算机网络复习<a hidden class="anchor" aria-hidden="true" href="#计算机网络复习">#</a></h1>
<p>OSI (Open Systems Interconnection) 参考模型和 TCP/IP 模型</p>
<p><img loading="lazy" src="./20201225/1.jpeg" alt=""  />
</p>
<p>TCP/IP 四层模型的代表<strong>协议</strong>：</p>
<ul>
<li>网络接口层（Link Layer）：ARP 协议（IP addr &mdash;ARP&mdash;&gt;MAC addr）</li>
<li>IP 网络层（Internet Layer）：IP、ICMP、IGMP 等协议。</li>
<li>传输层（Transport Layer）：TCP 和 UDP 协议</li>
<li>应用层（Application Layer）：HTTP、SMTP、DNS、FTP、SSH、DHCP、Telnet</li>
</ul>
<p>数据<strong>传输单位</strong>：</p>
<ul>
<li>物理层：比特</li>
<li>数据链路层：帧</li>
<li>网络层：数据报</li>
<li>传输层：报文段（TCP）、用户数据报（UDP）</li>
</ul>
<p><strong>TCP/IP 四层结构有什么优缺点？</strong></p>
<p>优点：</p>
<ul>
<li>TCP/IP 在设计之初就考虑到了多种异构网的互联问题，并将 IP 作为一个单独的重要层次。</li>
</ul>
<p>缺点：</p>
<ul>
<li>它在服务、接口与协议的区别上不清楚。</li>
<li>TCP/IP 的主机－网络层本身并不是实际的一层，它定义了网络层与数据链路层的接口。物理层与数据链路层的划分是必要和合理的，一个好的参考模型应该将它们区分开来，而 TCP/IP 参考模型却没有做到这点。</li>
</ul>
<p><strong>OSI 七层模型的优缺点？</strong></p>
<p>优点：</p>
<ul>
<li>OSI 参考模型的最大贡献就是精确定义了三个主要概念：服务、接口和协议。这与现代的面向对象程序设计思想非常吻合。</li>
<li>OSI 参考模型产生在协议发明之前，通用性较好。</li>
</ul>
<h2 id="2-tcp-的拥塞控制">2. TCP 的拥塞控制<a hidden class="anchor" aria-hidden="true" href="#2-tcp-的拥塞控制">#</a></h2>
<p><img loading="lazy" src="./20201225/18.jpeg" alt=""  />
</p>
<h3 id="21-慢启动">2.1 慢启动<a hidden class="anchor" aria-hidden="true" href="#21-慢启动">#</a></h3>
<p>慢启动机制</p>
<ul>
<li>初始窗口 initial cwnd，初始值设置为 3 或 10</li>
<li>慢启动门限值 ssthresh，初始值设置为 1 &laquo; 31</li>
<li>每收到 ACK，窗口值加 1</li>
</ul>
<p>慢启动并不慢</p>
<ul>
<li>在没有丢包情况下，经过 log2(target_cwnd/initial_cwnd) 个 RTT 长到目标窗口大小</li>
</ul>
<pre tabindex="0"><code>Initialization:
  cwnd &lt;- initial cwnd
if cwnd &lt; ssthresh:
  for each ack:
    cwnd += 1
else:
  for each ack:
    cwnd += 1/cwnd
when encountering loss:
  ssthresh &lt;- cwnd
  cwnd &lt;- cwnd/2
</code></pre><p>TCP 锯齿状窗口行为。</p>
<h3 id="22-快速重传">2.2 快速重传<a hidden class="anchor" aria-hidden="true" href="#22-快速重传">#</a></h3>
<ul>
<li>一般情况下，先发送的数据包应该先到达。如果后发送的数据包先被确认，可推测先发送的数据包丢失。</li>
<li>如果一个数据包后面的<strong>三个</strong>数据包都被确认，而该数据包还未收到确认，则认定该数据包丢失，并重传该数据包。</li>
<li>数据包通常都是连续发送的。快速重传通常可以在 1 个 RTT 内重传数据丢包。</li>
</ul>
<p><strong>为什么需要等 3 个后续数据包的确认?</strong></p>
<ul>
<li>防止因数据包乱序引起的误重传</li>
<li>在无线网络、多路径传输中会有部分乱序</li>
<li>假设网络中乱序长度不大于 3 个数据包</li>
<li>通过 D-SACK 机制 (Duplicate SACK) 识别一个数据包没有丢失，而是乱序。</li>
</ul>
<p><strong>一般来说，快速重传可以恢复长流中的大部分丢包。</strong></p>
<h3 id="32-超时重传">3.2 超时重传<a hidden class="anchor" aria-hidden="true" href="#32-超时重传">#</a></h3>
<ul>
<li>
<p>重传后丢包，即同一数据包被丢弃两次后，只能等待超时重传。</p>
</li>
<li>
<p>通过超时来判断数据包丢失</p>
</li>
<li>
<p>定时器至少大于一个 RTT (Round Trip Time)</p>
</li>
<li>
<p>定时器必须能够适应 RTT 变化，定时器必须同时反映出 RTT 大小和 RTT 变化</p>
</li>
<li>
<p>Linux 中最小值为 200ms</p>
</li>
</ul>
<h3 id="33-避免拥塞">3.3 避免拥塞<a hidden class="anchor" aria-hidden="true" href="#33-避免拥塞">#</a></h3>
<p><strong>流控（Flow Control）</strong>：</p>
<ul>
<li>为了防止快发送方给慢接收方发数据造成接收崩溃。注意与拥塞控制的区别。</li>
<li>发送方和接收方各自维护一个窗口大小</li>
</ul>
<p><strong>两种拥塞控制思路</strong>：</p>
<ul>
<li>端到端的拥塞控制：端设备通过丢包、延迟变化 等推测网络拥塞状况。TCP 使用端到端的拥塞控制策略。</li>
<li>网络辅助的拥塞控制：网络设备对端设备提供反馈。</li>
</ul>
<p><strong>TCP 的拥塞控制算法基础：</strong></p>
<ul>
<li>(1) TCP 端设备遇到丢包时，认为网络拥塞，减慢发送速率（发送速率（窗口大小）减半）</li>
<li>(2) TCP 端设备定期通过增大发送速率来探测更多可用带宽（每个 RTT，窗口值增加一个数据包大小）</li>
</ul>
<h3 id="-34-几种拥塞控制的方法总结">✅ 3.4 几种拥塞控制的方法总结<a hidden class="anchor" aria-hidden="true" href="#-34-几种拥塞控制的方法总结">#</a></h3>
<p>RFC 2581 定义了进行拥塞控制的四种算法，即慢开始（slow-start）、拥塞避免（congestion avoidance）、快重传（fast retransmit）和快恢复（fast recovery）。</p>
<p><strong>（1）慢开始（slow-start）和拥塞避免（congestion avoidance）</strong></p>
<p><img loading="lazy" src="./20201225/16.png" alt=""  />
</p>
<p><strong>（2）快重传（fast retransmit）和快恢复（fast recovery）</strong></p>
<p>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段 M3，而不必继续等待为 M3 设置的重传计时器到期。</p>
<p><img loading="lazy" src="./20201225/17.png" alt=""  />
</p>
<p>快恢复（fast recovery）门限 <code>ssthresh = cwnd / 2; cwnd = ssthresh; </code></p>
<h2 id="4-简述从输入网页网址到获得相关网页内容的步骤">4. 简述从输入网页网址到获得相关网页内容的步骤<a hidden class="anchor" aria-hidden="true" href="#4-简述从输入网页网址到获得相关网页内容的步骤">#</a></h2>
<p>（1）浏览器根据 DNS（Domain Name System，域名系统）服务器返回的真实地址请求网页，DNS 主要负责把对人类友好的网址转换为对机器友好的 IP 地址。</p>
<p>（2）浏览器请求计算机建立对这个 IP 地址的标准 Web 端口（80）或标准安全 Web 端口（443）的TCP（Transmission Control Protocol，传输控制协议）连接。</p>
<p>（3）当浏览器连接到 Web 服务器之后会请求网站，这一步就要用到 HTTP（或 HTTPS） 了。</p>
<p>（4）服务器会根据请求的 URL 响应相关内容。</p>
<p>（5）Web 浏览器负责处理返回的响应（HTML/CSS/JS）。</p>
<p>（6）Web 浏览器请求自己需要的额外资源。</p>
<p>（7）浏览器在获取了足够的关键资源后，开始在屏幕上渲染页面。</p>
<p>（8）在页面刚刚显示在屏幕上之后，浏览器会在后台继续下载其他资源，并在处理完它们之后更新页面。</p>
<p>（9）当页面完全被加载后，浏览器会停止显示加载图标（在多数浏览器上都位于地址栏旁边），然后触发 OnLoad JavaScript 事件。根据这个事件，JavaScript 就知道可以执行某些操作了。</p>
<p>（10）此时，页面已经完全加载了，但浏览器并不会停止发送请求。网页只包含静态内容的时代早就过去了。</p>
<h2 id="5-https-过程">5. HTTPS 过程<a hidden class="anchor" aria-hidden="true" href="#5-https-过程">#</a></h2>
<p><img loading="lazy" src="./20201225/2.png" alt=""  />
</p>
<ul>
<li>
<p>显然易见的是，非对称加密在性能上不如对称加密，两者各有其优缺点。HTTPS 就是将两者的优点结合起来。更具体的说就是，公钥私钥主要用于传输对称密钥，而真正的双方大量数据量的通信都是通过对称密钥进行的。</p>
</li>
<li>
<p>数字证书用来解决公钥的合法性问题。</p>
</li>
<li>
<p>非对称加密需要通过证书（Certificate）和权威机构 CA（Certificate Authority）来验证公钥的合法性。CA 通过层层授信背书的方式，从而确保了非对称加密模式的正常运转。</p>
</li>
</ul>
<p>我在 HTTPS 服务器的实验中，在数据传输之前，客户端和服务器会获取对方的证书，检查证书的基本信息（因为证书是自己签名的，没有权威 CA，因此不进行证书层层校验，直接认定是一个合法的证书），之后商量好对称密钥，使用对称密钥进行数据传输。</p>
<h2 id="6-简述区块链的技术原理和应用">6. 简述区块链的技术原理和应用<a hidden class="anchor" aria-hidden="true" href="#6-简述区块链的技术原理和应用">#</a></h2>
<h3 id="61-技术原理简述">6.1 技术原理简述<a hidden class="anchor" aria-hidden="true" href="#61-技术原理简述">#</a></h3>
<p>区块链（Blockchain）是一种创新的分布式交易验证和数据共享技术，也被称为分布式共享总账（Distributed Shared Ledger）。</p>
<p>区块（block）保存：</p>
<ul>
<li>（1）业务记录集合（以 hash link 的方式）</li>
<li>（2）前序块的哈希值（数字摘要）</li>
<li>（3）(1+2) 的哈希值（数字摘要）。</li>
</ul>
<p>每个记录中有发起者的数字签名，保证操作的<strong>不可伪造性</strong>和<strong>不可抵赖性</strong>。</p>
<p>链（chain），就是逻辑上由 “ (2) 前序块的哈希值” 串联起来的链条，保证<strong>不可删除</strong>、<strong>时序性</strong>和<strong>不可篡改</strong>特性。</p>
<p>后块为所有的前块背书，起到 “联保” 作用， 这样的数据结构即使是最初发布数据的人也不能改动他自己的数据了。</p>
<p>区块链解决的核心和本质问题是：无可信中心机构时，如何在信息不对称、不确定的环境下，建立满足活动赖以发生、发展的“信任”生态体系，即 “拜占庭容错”或者“两军问题”。</p>
<p><img loading="lazy" src="./20201225/3.jpeg" alt=""  />
</p>
<h3 id="62-应用简述">6.2 应用简述<a hidden class="anchor" aria-hidden="true" href="#62-应用简述">#</a></h3>
<p>区块链技术的适用场景：</p>
<ul>
<li>多方参与</li>
<li>缺乏统一信任主体</li>
<li>存在价值流通或信任传递</li>
</ul>
<p>工信部《中国区块链技术和应用发展白皮书》</p>
<p><img loading="lazy" src="./20201225/4.jpg" alt=""  />
</p>
<p><strong>区块链热点应用案例：</strong></p>
<ul>
<li>供应链金融，现有问题：造假风险、企业信息孤岛、履约风险高。</li>
<li>支付、清算、结算，现有问题：造假资金滞后、成本高昂。</li>
<li>跨境贸易，现有问题：数据缺乏共享，形成数据孤岛；参与方之间信任缺失；流程协同低效；中心平台透明度低，依赖性强。</li>
<li>政务现代化，现有问题：信息资源不共享、不开放、成本高昂；⺴络安全存在隐患；多方介入，效率低下；缺乏法律制度保障。</li>
<li>人力资源，现有问题：学历造假、履历造假、绩效管理不透明。</li>
<li>司法版权</li>
<li>电子发票</li>
<li>医疗健康</li>
<li>智能制造</li>
<li>小额数字资产</li>
<li>国家法定数字货币</li>
</ul>
<h2 id="7-数据中心网络数据级流和流量级流的优劣势">7. 数据中心网络，数据级流和流量级流的优劣势<a hidden class="anchor" aria-hidden="true" href="#7-数据中心网络数据级流和流量级流的优劣势">#</a></h2>
<ul>
<li>流量模式不固定，分钟级别的变化都可能很大</li>
</ul>
<p>ECMP, “Equal Cost Multi Path”：流级别的负载均衡</p>
<ul>
<li>使用 HASH （source-addr, dst-addr, source-port, dst-port）</li>
<li>优势：一条流的数据包在相同的 path 上</li>
<li>不足：elephants flows</li>
</ul>
<p>VL2：Virtual Layer 2（整个网络看做是一个二层交换机）基于<strong>实际数据</strong>出发，使用已有的技术，实现可
扩展、敏捷的数据中心网络。</p>
<ul>
<li>优点：每条流随机选择中间交换机（Intermediate）转发，随机性解决不稳定性</li>
<li>缺点：（1）目录服务器的引入是否会成为瓶颈? （2）为了实现 VLB，所有链路、所有交换机一直在线，能耗高。</li>
</ul>
<h2 id="8-ndn-的体系结构">8. NDN 的体系结构<a hidden class="anchor" aria-hidden="true" href="#8-ndn-的体系结构">#</a></h2>
<p>NDN 的体系结构改变的是现行网络体系结构的哪些部分？为什么 NDN 很难部署？</p>
<p>NDN：Named Data Networking</p>
<p>目前互联网面临的问题：大量的补丁使得 IP 网络系统越来越复杂，而且可能阻碍业务的创新。</p>
<ul>
<li>流量激增</li>
<li>移动性支持</li>
<li>安全/管理控制问题</li>
</ul>
<p>新的体系结构，核心：naming，addressing。</p>
<p>NDN 解决三个关联问题。</p>
<p><img loading="lazy" src="./20201225/5.jpeg" alt=""  />
</p>
<p>接收方的数据传输：一个 Interest 对应一个 Data</p>
<p>带状态、hop-by-hop 数据传输：Data 沿着 Interest 的反向路径传输回去</p>
<p>NDN 安全：</p>
<ul>
<li>完整性、正确性：IP 的管道安全&mdash;&gt;NDN 的内容安全</li>
<li>DoS 攻击：(1) 一个 Interest 对应一个 Data，不会引起 Data 的 flooding。(2) 相同的 Interest 在可以在 Pending Interest Table 中屏蔽。</li>
</ul>
<p><strong>NDN 缺点导致难以部署：</strong></p>
<ul>
<li>带状态的网络，将使得网络设备的实现和维护复杂</li>
<li>名字是不定长的，路由表查找困难</li>
<li>交互式应用支持问题</li>
<li>路由表规模非常庞大</li>
</ul>
<h2 id="9-bbr-测量链路瓶颈">9. BBR 测量链路瓶颈<a hidden class="anchor" aria-hidden="true" href="#9-bbr-测量链路瓶颈">#</a></h2>
<p>BBR：在 TCP 的演进历史中，在不降低吞吐率的前提下减少延迟。是 TCP 拥塞控制算法优化。</p>
<p>BBR (Bottleneck Bandwidth and RTT) 设计目标：在不降低吞吐率的同时，减少网络延迟。</p>
<ul>
<li>(1) 每次收到 ACK 后，更新对 Max Throughput 和 Min RTT 的估计</li>
<li>(2) 通过控制发送数据量来探测 Max Throughput 和 Min RTT</li>
</ul>
<p>BBR 测量链路瓶颈带宽和 RTT，为什么不能同时测量？如何请求测量这两个值？</p>
<p>BBR 的基本理念就是尽量估算 $RTT_{prop}$ 和 Bottleneck BW 这两个参数。</p>
<p>$$cwnd=2\times BDP=2\times (RTT_{prop} + btlBW)$$</p>
<p>$RTT_{prop}$ 和 Bottleneck BW 是两个重新审视拥塞控制的参数:</p>
<ul>
<li>$RTT_{prop}$：round-trip propagation time</li>
<li>btlBW： bottleneck bandwidth</li>
</ul>
<p>类比水管的话，$RTT_{prop}$ 就是水管的长度，btlBW 就是水管的宽度。</p>
<p>我也不知道怎么测？</p>
<p><img loading="lazy" src="./20201225/6.jpeg" alt=""  />
</p>
<h2 id="10-内容分发-cdn">10. 内容分发 CDN<a hidden class="anchor" aria-hidden="true" href="#10-内容分发-cdn">#</a></h2>
<p>访问局部性：</p>
<ul>
<li>80-20 准则、zipf 定律：20% 的内容吸引 80% 的访问（10-20% 的内容产生 80% 的访问）</li>
</ul>
<p>CDN: Content Delivery Network：把内容拷⻉到不同地域的多台服务器， 减轻服务器负载，提升用户感知的质量。</p>
<p>CDN 主动发布内容：<strong>原始服务器</strong>发布内容到 <strong>CDN 分发节点</strong>，CDN 主动复制内容到其他服务器。</p>
<p>CDN 核心问题：选择哪个服务器？</p>
<ul>
<li>CDN 提供商持续监测服务器的负载、性能</li>
<li>距离客户端近的服务器</li>
</ul>
<p>静态配置：通过 HTTP Redirect 实现</p>
<ul>
<li>比如：来自北京的请求，都<strong>重定向</strong>到北京的服务器</li>
</ul>
<p>DNS 回顾：</p>
<p><img loading="lazy" src="./20201225/7.jpeg" alt=""  />
</p>
<p>Akamai：全球最大的 CDN。Akamai 工作原理：</p>
<p><img loading="lazy" src="./20201225/8.jpeg" alt=""  />
</p>
<ul>
<li>NS-based mapping</li>
</ul>
<p>$MAP_t = \sum_{internet} \times \sum_{Akamai}\times Domain \times LDNS \rightarrow IPs$</p>
<ul>
<li><strong>end-user mapping</strong></li>
</ul>
<p>$EUMAP_{t} = \sum_{internet} \times \sum_{Akaamai} \times Domain  \times Client \rightarrow IPs $</p>
<p>CDN 面临的挑战：</p>
<ul>
<li>网络层面：(1) CDN服务器所在⺴络与其他⺴络的互联问题；(2) 内容传输效率问题</li>
<li>应用层面：(1) 内容放置问题(地域)：内容复制到哪些服务器上? (2) 存储问题:多大的存储空间?</li>
</ul>
<h2 id="11-路由器交换机-buffer-队列">11. 路由器/交换机 Buffer 队列<a hidden class="anchor" aria-hidden="true" href="#11-路由器交换机-buffer-队列">#</a></h2>
<p>数据包队列是网络中间设备中最关键的部分之一，其大小、管理策略等很大程度上影响了网络性能。</p>
<p>队列应该设为多大？</p>
<ul>
<li>$BufferSize=\bar{RTT} \times C$: $\bar{RTT}$ 为端到端平均链路延迟，C 为瓶颈链路带宽。</li>
</ul>
<p>队列大小与<strong>队列管理策略、传输控制策略</strong>等关系密切。</p>
<p>队列大小决定传输速率，传输控制策略影响了队列行为。</p>
<p><strong>队列过大：</strong>$BufferSize &gt; \bar{RTT} \times C$，当窗口减半时，队列不能清空数据包，因此数据包的<strong>延迟</strong>会增加。</p>
<p><strong>队列过小</strong>：$BufferSize &lt; \bar{RTT} \times C$，当窗口大小减半时，发送方在等待对方的数据确认，因此瓶颈链路处于空<strong>闲</strong>状态。</p>
<p>数据中心网络的交换机队列：队列相对过<strong>小</strong> (under-buffered) 造成了 TCP-Incast 问题。</p>
<p>广域网的路由转发设备队列：队列过<strong>大</strong> (over-buffered) 造成了 BufferBloat 问题。</p>
<p>解决 BufferBloat 问题：</p>
<ul>
<li>减小队列大小</li>
<li>改进传输控制策略</li>
<li>改进队列管理策略</li>
<li>Tail Drop (尾部丢弃)</li>
<li>RED (Random Early Detection)：主动 (proactively) 丢包 (Early Detection)，概率性丢包。</li>
<li>CoDel (Controlling Delay)：控制数据包在队列中的时间(延迟)，而不是队列长度。</li>
</ul>
<p><strong>数据包队列总结：</strong></p>
<ul>
<li>队列是网络设备中的关键部分，其大小、管理策略影响了网络性能。</li>
<li>队列设置过大或过小都容易产生问题。过小 &ndash;&gt; TCP Incast 问题，过大 &ndash;&gt; BufferBloat 问题</li>
<li>队列大小、队列管理策略、传输控制策略之间的关系非常紧密。</li>
</ul>
<h2 id="12-fib-计算算法ipv4-trie-树ipv6-的优化方法">12. FIB 计算算法、IPv4 Trie 树、IPv6 的优化方法<a hidden class="anchor" aria-hidden="true" href="#12-fib-计算算法ipv4-trie-树ipv6-的优化方法">#</a></h2>
<p>FIB (Forwarding Information Base)，路由器转发表。转发表中存储的是网络号与下一跳地址的映射关系</p>
<h3 id="211-ip报文转发规则">21.1 IP报文转发规则<a hidden class="anchor" aria-hidden="true" href="#211-ip报文转发规则">#</a></h3>
<p>路由器收到 IP 报文后，获取目的地址 D，按照如下规则进行转发:</p>
<p>（1）如果 D 与路由器在同一网络内，直接交付给主机 D，并返回;</p>
<p>（2）在转发表中进行最长前缀匹配，如果匹配成功，则将 IP 报文转发到该下一跳网关，并返回;</p>
<p>（3）如果转发表中有默认路由，则将IP报文转发给默认路由器，并返回;</p>
<p>（4）报告转发分组出错（ICMP，目的网络不可达）。</p>
<h3 id="122-trie">12.2 Trie<a hidden class="anchor" aria-hidden="true" href="#122-trie">#</a></h3>
<p>高速查找、快速更新和可拓展的虚拟路由器 IP 查找方法！</p>
<p><img loading="lazy" src="./20201225/9.jpeg" alt=""  />
</p>
<p>每增加一个 trie 树，节点大小只增加 1 比特。存储 14 个 IPv4 核心路由器 FIB，trie 树大小仅为 10MB。</p>
<p>决策树算法的缺点：在决策树算法中，90% 的内存占用来自规则的复制。</p>
<h3 id="123-ipv6">12.3 IPv6<a hidden class="anchor" aria-hidden="true" href="#123-ipv6">#</a></h3>
<ul>
<li>IPv6 地址长度为 128 位。IPv6 地址用十六进制表示，分为 8 段，中间用 <code>:</code> 隔开：</li>
</ul>
<pre tabindex="0"><code>2001:0410:0000:0001:0000:0000:0000:45ff
</code></pre><ul>
<li>每段的起始 0 可以省略，连续全零的段可用 <code>::</code> 表示（只能出现一次）</li>
</ul>
<pre tabindex="0"><code>2001:410:0:1:0:0:0:45ff, 2001:410:0:1::45ff
</code></pre><ul>
<li>不同起始码对应不同类型 IPv6 地址，例如 <code>::ffff/96</code> 表示与 IPv4 兼容的地址</li>
</ul>
<p>128 为的 IPv6 的优势：更容易进行层次化（Hierarchical）编址。</p>
<p><strong>MAC 地址转换为 IPv6 地址：</strong></p>
<ul>
<li>先将 MAC 地址转换为 EUI-64 标识（64 位全球唯一标识 (Extended Unique Identifier)）</li>
<li>IPv6 网络前缀 (64 位) + EUI-64 地址</li>
</ul>
<p><img loading="lazy" src="./20201225/10.jpeg" alt=""  />
</p>
<p><strong>IPv4 地址到 IPv6 地址的映射：</strong></p>
<ul>
<li>前缀为 <code>::ffff/96</code> 是保留一小部分地址与 IPv4 兼容的</li>
<li><strong>数据报在这两类节点之间转发时，需要进行地址的转换</strong> NAT-PT (Protocol Translator）</li>
</ul>
<p><img loading="lazy" src="./20201225/11.jpeg" alt=""  />
</p>
<p>IPv6 取消了 ARP 协议。通过邻居请求报文（NS）和邻居通告报文（NA）来解析三层地址对应的链路层地址。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://landodo.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://landodo.github.io/posts/20201230-ten-classic-sorting-algorithms/">
    <span class="title">« Prev Page</span>
    <br>
    <span>十大经典的排序算法</span>
  </a>
  <a class="next" href="http://landodo.github.io/posts/20201218-computer-network/">
    <span class="title">Next Page »</span>
    <br>
    <span>计算机网络基础（2）</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>Landon</span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>

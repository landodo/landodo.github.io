<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">


<meta name="robots" content="index, follow">
<title>使用 C 语言实现一个 HTTP 服务器（1） | Notes</title>
<meta name="keywords" content="计算机网络, HTTP, 面试" />
<meta name="description" content="HTTP Server⟹HTTPS Server: 实验要求 这是网络课的一个小作业，具体要求如下： 使用 C 语言实现一个 HTTP 服务器 支持 HTTP Post/Get 方法，可以上传或下载文件 支持 HTTP 分">
<meta name="author" content="">
<link rel="canonical" href="http://landodo.github.io/posts/20201107-http-server-1/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css" integrity="sha256-yIlj/i15RiAA/Q&#43;xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as="style">
<link rel="preload" href="./logo.png" as="image">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js" integrity="sha256-uVus3DnjejMqn4g7Hni&#43;Srwf3KK8HyZB9V4809q9TWE="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://landodo.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://landodo.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://landodo.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://landodo.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="http://landodo.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="使用 C 语言实现一个 HTTP 服务器（1）" />
<meta property="og:description" content="HTTP Server⟹HTTPS Server: 实验要求 这是网络课的一个小作业，具体要求如下： 使用 C 语言实现一个 HTTP 服务器 支持 HTTP Post/Get 方法，可以上传或下载文件 支持 HTTP 分" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://landodo.github.io/posts/20201107-http-server-1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-07T10:17:29&#43;08:00" />
<meta property="article:modified_time" content="2020-11-07T10:17:29&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="使用 C 语言实现一个 HTTP 服务器（1）"/>
<meta name="twitter:description" content="HTTP Server⟹HTTPS Server: 实验要求 这是网络课的一个小作业，具体要求如下： 使用 C 语言实现一个 HTTP 服务器 支持 HTTP Post/Get 方法，可以上传或下载文件 支持 HTTP 分"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://landodo.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "使用 C 语言实现一个 HTTP 服务器（1）",
      "item": "http://landodo.github.io/posts/20201107-http-server-1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "使用 C 语言实现一个 HTTP 服务器（1）",
  "name": "使用 C 语言实现一个 HTTP 服务器（1）",
  "description": "HTTP Server⟹HTTPS Server: 实验要求 这是网络课的一个小作业，具体要求如下： 使用 C 语言实现一个 HTTP 服务器 支持 HTTP Post/Get 方法，可以上传或下载文件 支持 HTTP 分",
  "keywords": [
    "计算机网络", "HTTP", "面试"
  ],
  "articleBody": "HTTP Server⟹HTTPS Server: 实验要求 这是网络课的一个小作业，具体要求如下：\n使用 C 语言实现一个 HTTP 服务器\n支持 HTTP Post/Get 方法，可以上传或下载文件\n支持 HTTP 分块传输，支持 HTTP 持久连接和管道\n使用 openssl 库，支持 HTTPS\n使用 libevent 支持多路并发\n提交：代码和实验报告，实现越完整越好，测试越充分越好\n前置知识 HTTP 无所不在，我们日常访问的网站都在 HTTP 服务器上运行。\n现在更常见的是 HTTPS，从技术的角度上看，HTTPS 相比于 HTTP 来说具有更高的安全性。\n如何构建 HTTP 服务器呢？这其实是非常简单的。在开始之前，需要先复习一下基本的网络知识。\n1. OSI 首先，需要对 OSI 有一个基本的认识和了解。\nOSI 全称为 Open Systems Interconnection。\nOSI 模型是一个概念模型，它对电信或计算系统的通信功能进行描述和标准化，而不考虑其基本的内部结构和技术。\n它的目标是用标准协议实现不同通信系统的互操作性。该模型将通信系统划分为若干抽象层。该模型的最初版本定义了七个层。\n图片链接：OSI 七层模型\n为了实现 HTTP 服务器，需要关心的是第四层——传输层（Transport Layer）。\n2. 传输层（Transport Layer） 传输层主要负责确保数据可靠无误地从一个点传输到另一个点。例如，传输层确保数据以正确的顺序发送和接收。\n传输层提供流控制和错误处理，并参与解决有关数据包的传输和接收问题。传输层协议的常见例子有传输控制协议（TCP）、用户数据报协议（UDP）和顺序包交换（SPX）。\n在传输层，主要使用 TCP 来实现 HTTP 服务器。虽然也可以使用 UDP 实现，但是并没有很多人这么做。\nHTTP 通信通常通过 TCP/IP 连接进行。默认端口是 TCP 80，但也可以使用其他端口。这并不排除 HTTP 在 Internet 上或其他网络上的任何其他协议之上实现。\nHTTP 只预设了一个可靠的传输，任何提供这种保证的协议都可以使用，HTTP/1.1 请求和响应结构在有关协议的传输数据单元上的映射不在本规范的范围之内。\n——RFC 2616\n所有著名的 HTTP 服务器如 Apache Tomcat、NginX 等都是在 TCP 之上实现的。所以，使用基于 TCP 的 HTTP 服务器是一个正确的选择。\n3. RFC RFC 是什么？\nRFC 全称为 Request for Comments。\nRequest for Comments 文件是 Steve Crocker 在 1969 年发明的，用于帮助记录 ARPANET 发展的非官方笔记。此后，RFCs 成为互联网规范、通信协议、程序和事件的正式文件。\n截至 2017 年 8 月，共有 8200 多个 RFC。\n万维网上 RFCs 的官方来源是 RFC Editor。\n一些标准化的RFC有。\nHTTP/1.1 → 最初是 RFC 2616，后来被 RFC 7230、RFC 7231、RFC 7232、RFC 7233、RFC 7234、RFC 7235 取代。所以，需要从 RFC 7230 到 RFC 7235 来实现 HTTP 的基本工作原理。 HTTP/2 → RFC 7540 和 RFC 7541 FTP → RFC959 所以，如果要实现 HTTP 服务器，可以先阅读特定的 RFC，即 RFC 7230、RFC 7231、RFC 7232、RFC 7233、RFC 7234、RFC 7235。\n4. TCP Socket 要实现 TCP，我们必须学习 TCP Socket 编程。\nSocket 也叫做套接字。\n套接字是大多数流行的操作系统提供的让程序访问网络的机制，它允许不同网络机器上的应用程序（无关的进程）之间收发消息。它允许在不同网络机器上的应用程序（不相关的进程）之间发送和接收消息。\n套接字机制是为了独立于任何特定类型的网络而创建的。\nIP 是迄今为止最主要的网络，也是套接字最流行的用途。\nSocket 编程的几个重要步骤\n创建 Socket 绑定 Socket 服务器端等待连接 发送和接收消息 关闭 Socket Socket 编程 实现一个基于 TCP 通信的服务器。\n第 1 步：创建 Socket socket 函数：man socket\nNAME socket -- create an endpoint for communication SYNOPSIS #include int socket(int domain, int type, int protocol); domain：域名或地址族通信域，套接字应在其中创建。一些地址族有 AF_INET(IP)、AF_INET6(IPv6)、AF_UNIX（本地通道，类似管道）、AF_ISO（ISO 协议）和 AF_NS（Xerox 网络系统协议)。 type：服务类型。这要根据应用所需的属性来选择。SOCK_STREAM（TCP 字节流）、SOCK_DGRAM（数据报服务）、SOCK_RAW（直接 IP 服务）。 protocol：对于 TCP/IP 套接字，要指定 IP 地址族为 AF_INET 和虚拟电路服务（SOCK_STREAM）。由于虚拟电路服务只有一种形式，所以没有协议的变化，所以最后一个参数 protocol 为零。 示例：\n// 1. 创建 TCP Socket int sfd = socket(AF_INET, SOCK_STREAM, 0); 第 2 步：绑定 Socket 创建套接字后，需要给套接字绑定（bind）一个网络传输地址。\nint bind(int socket, const struct sockaddr *address, socklen_t address_len); 第一个参数 socket 是第 1 步所创建的 sfd。 第二个参数，sockaddr 是一个结构体数据，对于 IP 网络，使用的是 sockaddr_in，它在头netinet/in.h 中定义 第三个参数一半传入sizeof(svr_addr). // #include // sockaddr_in /* * Socket address, internet style. */ struct sockaddr_in { __uint8_t sin_len; sa_family_t sin_family; in_port_t sin_port; struct in_addr sin_addr; char sin_zero[8]; }; sin_family：socket 使用的地址族。本次实现的 TCP ，它是 AF_INET。 sin_port：端口号 sin_addr：IP 地址，是一个 32 位的无符号整型 struct in_addr { in_addr_t s_addr; }; typedef __uint32_t in_addr_t; /* base type for internet address */ 使用示例：（这里还涉及大端序和小端序的知识）\n// 2. bind() 绑定 IP 和端口号 struct sockaddr_in svr_addr; //用于填写服务器的 IP 地址与端口号 svr_addr.sin_family = AF_INET; //地址族 svr_addr.sin_port = htons(8888); //端口号 svr_addr.sin_addr.s_addr = inet_addr(\"10.203.11.153\"); // IP 地址 if (bind(sfd, (const struct sockaddr *)\u0026svr_addr, sizeof(svr_addr)) \u003c 0) { perror(\"bind() error\"); exit(EXIT_FAILURE); } 第 3/4 步：服务器监听端口等待连接 建立监听队列，等待连接。\n#include int listen(int socket, int backlog); 第二个参数 backlog 定义了在拒绝连接之前可以排队等待的最大连接数。\n使用示例：\n// 3. 建立监听队列 if (listen(sfd, 10) \u003c 0) { perror(\"listen()\"); //输出出错原因 exit(EXIT_FAILURE); //退出应用程序 } accept 系统调用会抓取待处理连接队列中的第一个连接请求，并为该连接创建一个新的套接字。\n原来为监听而设置的套接字只用于接受连接，不用于交换数据。默认情况下，套接字操作是同步的，或者说是阻塞的，accept 会阻塞，直到队列上有连接存在。\n#include int accept(int socket, struct sockaddr *restrict address, socklen_t *restrict address_len); 第一个参数 socket 是设置用于接受监听连接的 socket。 第二个参数 address 是与进行连接的客户端的地址一起归档的地址结构。这样我们就可以在需要的时候检查连接 socket 的地址和端口号。 第三个参数是填入地址结构的长度。 使用示例：\n// 4. 服务器接收客户端的连接请求 // 记录客户端的地址信息 struct sockaddr_in client_addr; socklen_t len = sizeof(client_addr); int cfd = accept(sfd, (struct sockaddr *)\u0026client_addr, \u0026len); if (cfd == -1) { perror(\"accept() error!\\n\"); exit(EXIT_FAILURE); } 第 5/6 步：接收/发送数据 现在终于把客户端（当从网页浏览器访问服务器的 IP 地址时）和服务器之间的套接字连接起来了。\n// 第4步连接成功，打印出客户端的 IP 和端口号 printf(\"client ip: %s, port: %d\\n\", inet_ntoa(client_addr.sin_addr), htons(client_addr.sin_port)); // 5. 接收客户端的数据 server \u003c------ client char recv_buffer[1024] = {'\\0'}; ssize_t rbytes = recv(cfd, recv_buffer, sizeof(recv_buffer), 0); if (rbytes == -1) { perror(\"recv() error!\\n\"); exit(EXIT_FAILURE); } printf(\"recv: %s\\n\", recv_buffer); // 6. 向客户端发送数据： server ------\u003e client char send_buffer[1024] = \"Hello, Client. Your IP is \"; strcat(send_buffer, inet_ntoa(client_addr.sin_addr)); size_t sbytes = send(cfd, send_buffer, strlen(send_buffer)+1, 0); if (sbytes == -1) { perror(\"send() error!\\n\"); exit(EXIT_FAILURE); } 第 7 步：关闭 Socket 最后，别忘了关闭 Socket。\n// 关闭连接 close(cfd); TCP Socket 服务器端完整代码 // HTTP_server.c #include #include // exit #include // inet_ntoa #include // sockaddr_in #include // strlen #include // close function int main() { // 1. 创建 Socket 套接字 int sfd = socket(AF_INET, SOCK_STREAM, 0); if (sfd == -1) { perror(\"socket() error!\\n\"); exit(EXIT_FAILURE); } // 2. bind() 绑定 IP 和端口号 struct sockaddr_in svr_addr; //用于填写服务器的ip地址与端口号 svr_addr.sin_family = AF_INET; //地址族 svr_addr.sin_port = htons(8888); //端口号 svr_addr.sin_addr.s_addr = inet_addr(\"10.203.11.153\"); //ip地址 if (bind(sfd, (const struct sockaddr *)\u0026svr_addr, sizeof(svr_addr)) \u003c 0) { perror(\"bind()\"); exit(EXIT_FAILURE); } // 3. 建立监听队列 if (listen(sfd, 10) \u003c 0) { perror(\"listen()\"); exit(EXIT_FAILURE); } // 4. 服务器接收客户端的连接请求 // 记录客户端的地址信息 struct sockaddr_in client_addr; socklen_t len = sizeof(client_addr); int cfd = accept(sfd, (struct sockaddr *)\u0026client_addr, \u0026len); if (cfd == -1) { perror(\"accept() error!\\n\"); exit(EXIT_FAILURE); } // 连接成功，打印出客户端的 IP 和端口号 printf(\"client ip: %s, port: %d\\n\", inet_ntoa(client_addr.sin_addr), htons(client_addr.sin_port)); // 5. 接收客户端的数据 server \u003c------ client char recv_buffer[1024] = {'\\0'}; ssize_t rbytes = recv(cfd, recv_buffer, sizeof(recv_buffer), 0); if (rbytes == -1) { perror(\"recv() error!\\n\"); exit(EXIT_FAILURE); } printf(\"recv: %s\\n\", recv_buffer); // 6. 向客户端发送数据： server ------\u003e client char send_buffer[1024] = \"Hello, Client. Your IP is \"; strcat(send_buffer, inet_ntoa(client_addr.sin_addr)); size_t sbytes = send(cfd, send_buffer, strlen(send_buffer)+1, 0); if (sbytes == -1) { perror(\"send() error!\\n\"); exit(EXIT_FAILURE); } // 7. 关闭连接 close(cfd); close(sfd); return 0; } 客户端的写法是：socket() - connect() - send() - recv() - close()。\n这里我偷懒了，直接使用一个简单的「网络调试助手」来替代客户端。\n测试结果 1、服务器 IP 和监听的端口号\nsvr_addr.sin_port = htons(8888); //端口号 svr_addr.sin_addr.s_addr = inet_addr(\"10.203.11.153\"); //IP 地址 2、启动服务器（配置 IP 地址为自己电脑的）\n➜ Build-a-simple-HTTP-server gcc HTTP_server.c ➜ Build-a-simple-HTTP-server ./a.out 3、客户端连接服务器，发送 “Hello, Server! This is Client.”\n4、观察结果：服务器端接收到了客户端发送的消息；客户端接收区接收到了服务器的消息。\n总结 程序运行能够在应用程序之间进行通信。这意味着以上实现的 TCP 实现工作正常。\n至此已经完成了最基本的编码部分。\n现在继续进行 HTTP 服务器的实现。\nHTTP 服务器 首先看看服务器和 Web 浏览器之间的交互。\n再把 HTTP 部分放大，进行更加细致的了解。\nHTTP Client（即 Web 浏览器）向 HTTP Server 发送 HTTP 请求。 服务器处理收到的请求，并向 HTTP Client 发送 HTTP 响应。 现在，细致的客户端-服务器，以及它们发送和接收的内容。\nHTTP Client HTTP 客户端（Web浏览器）是请求的发起者。\n向浏览器中输入一个连接：\nhttp://www.example.com 为了显示页面，浏览器从 Web 服务器 80 端口获取文件 index.html（默认网页）。发出的请求如下：\n现在，HTTP_server.c 先不做任何修改，运行程序，启动服务器。直接在浏览器中输入 l0.203.11.153:8888 ，看看会发生什么。\n该网页无法正常运行。\n在看看服务器端输出了什么：\n非常有意思，这值得好好看一看。第一行：\nclient ip: 10.203.11.153, port: 54813 这是我们的服务器端自己 printf 的，第二行的 “recv:” 也是，不算。所有服务器端接收到的内容应该是：\nGET / HTTP/1.1 Host: 10.203.11.153:8888 Connection: keep-alive Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3 Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7,und;q=0.6,es;q=0.5,fr;q=0.4,zh-TW;q=0.3,ja;q=0.2 按理说服务器接收到客户端的连接后，应该会向客户端发送 “Hello, Clinet, ….\"，但是网页却无法正常运行。\n// 6. 向客户端发送数据： server ------\u003e client char send_buffer[1024] = \"Hello, Client. Your IP is \"; strcat(send_buffer, inet_ntoa(client_addr.sin_addr)); size_t sbytes = send(cfd, send_buffer, strlen(send_buffer)+1, 0); 要解决这个问题，就要了解一下 HTTP 的知识了。\nHTTP Methods GET 是 HTTP 默认使用的方法，如上面终端中，Server 接收到的信息，第一行就是一个 GET。\n常用的 HTTP Methods：\nGET：获取一个 URL。 HEAD：获取一个 URL 的信息。 PUT：存储到一个 URL。 POST：将表单数据发送至一个 URL 并获得响应。 DELETE：删除一个 URL GET 和 POST（表单）是常用的。 HTTP Server 客户端发送了一些头信息（GET …），希望服务器做出响应的响应。\n但我们自己实现的 HTTP_server 只发送了一个问候信息，这缺少一些必要的头信息，这就是问题的所在。\n// 6. 向客户端发送数据： server ------\u003e client char send_buffer[1024] = \"Hello, Client. Your IP is \"; strcat(send_buffer, inet_ntoa(client_addr.sin_addr)); size_t sbytes = send(cfd, send_buffer, strlen(send_buffer)+1, 0); 浏览器希望得到的是一个与请求相同格式的数据。\nHTTP 不过是遵循 RFC 文件中指定的一些规则，它的实现与语言无关。\n如下是网络浏览器所期待的 HTTP 响应格式的例子。显示的头信息只是一个例子。HTTP 中还有很多头信息存在，具体可以看 HTTP RFCs → RFC 7230, RFC 7231, RFC 7232, RFC 7233, RFC 7234, RFC 7235。\n如果想从服务器发送 Hello：\n首先需要构造 Header，\n然后插入一个空行\n之后我们就可以发送消息/数据。\n现在，开始构造一个最小的 HTTP Header 来使 HTTP 服务器正常工作。\nchar send_buffer[1024] = \"HTTP/1.1 200 OK\\nContent-Type: text/plain\\nContent-Length: 39\\n\\nHello, Client. Your IP is \"; strcat(send_buffer, inet_ntoa(client_addr.sin_addr)); 如上的 3 个头信息是最低要求。\nHTTP/1.1 200 OK ：使用的 HTTP 版本号、状态码和状态信息。 Content-Type: text/plain ：服务器发送的是纯文本。Content-Type 还有其他的格式。 Content-Length: 39 ：服务器向客户端发送 39 字节。网络浏览器只读取我们在这里提到的数量。 最后一部分是 Body。在这里发送自定义的数据。 首先，需要在 Body 中计算出发送的字节数，与 Content-Length 相同。 \"Hello, Client. Your IP is 10.203.11.153\" 的长度刚好等于 39 字节。\n客户端将会接收到：\nHTTP/1.1 200 OK Content-Type: text/plain Content-Length: 39 Hello, Client. Your IP is 10.203.11.153 浏览器访问 IP:8888，可以看到工作正常。\n关于状态码和状态信息：\n状态码是服务器根据客户向服务器提出的请求而发出的。它包括 IETF Request for Comments (RFCs)、其他规范中的代码，以及超文本传输协议（HTTP）的一些常见应用中使用的附加代码。\n状态码的第一个数字指定了五种标准响应类别中的一种。所显示的消息短语是典型的，但可以提供任何人类可读的替代方案。除非另有说明，否则状态码是 HTTP/1.1 标准（RFC 7231）的一部分。\n所以，如果服务器找不到客户端要求的文件，那么就发送适当的状态码。\n如果客户端没有权限查看文件，那么就发送相应的状态码。\n常见的状态码：\n200 OK\n403 Forbidden\n404 Not Found\n502 Bad Gateway\nInformational responses (100–199),\nSuccessful responses (200–299),\nRedirects (300–399),\nClient errors (400–499),\nand Server errors (500–599).\n现在，HTTP 已经正常工作了。虽然它非常非常的简陋。\n客户端请求网页（理论） 到现在为止，已经实现一个能向浏览器客户端发送一个字符串的 HTTP 服务器。\n现在，来看看如何发送一个文件、图片等信息。假设在地址栏中输入：\nIP:8888/info.html 在服务器终端，将会得到如下请求。\nGET /info.html HTTP/1.1 Host: 10.203.11.153:8888 Connection: keep-alive Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3 Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7,und;q=0.6,es;q=0.5,fr;q=0.4,zh-TW;q=0.3,ja;q=0.2 看一看请求头中的第一行。\nGET /info.html HTTP/1.1 所以，服务器只需要在当前目录下搜索 info.html 文件。\n当然还有很多情况需要服务器考虑，例如：\n文件（网页）是存在的 文件（网页）不存在 客户端没有访问文件（网页）的权限。 ….. 服务器端需要做的是：\n选择合适的状态码； 如果文件是存在的，并且客户端有权限访问它，选择合适的 Content-Type； 然后打开文件，将数据读到一个变量中。统计从文件中读取的字节数； 设置 Content-Length； 构造 Response Header； 在 Response Header 的末尾添加一个新行，并将从文件中读取的数据追加到其中； 发送给客户端。 参考链接 HTTP Server: Everything you need to know to Build a simple HTTP server from scratch HTTP Status Codes ",
  "wordCount" : "5038",
  "inLanguage": "en",
  "datePublished": "2020-11-07T10:17:29+08:00",
  "dateModified": "2020-11-07T10:17:29+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://landodo.github.io/posts/20201107-http-server-1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Notes",
    "logo": {
      "@type": "ImageObject",
      "url": "http://landodo.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://landodo.github.io/" accesskey="h" title="Notes (Alt + H)">
                <img src="http://landodo.github.io/logo.png" alt="logo" aria-label="logo"
                    height="30">Notes</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="http://landodo.github.io/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://landodo.github.io/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="http://landodo.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://landodo.github.io/tags" title="Tag">
                    <span>Tag</span>
                </a>
            </li>
            <li>
                <a href="http://landodo.github.io/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="http://landodo.github.io/cs-zoo" title="CS ZOO">
                    <span>CS ZOO</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://landodo.github.io/">Home</a>&nbsp;»&nbsp;<a href="http://landodo.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      使用 C 语言实现一个 HTTP 服务器（1）
    </h1>
    <div class="post-meta"><span title='2020-11-07 10:17:29 +0800 CST'>November 7, 2020</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;5038 words

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#http-serverhttps-server" aria-label="HTTP Server⟹HTTPS Server:">HTTP Server⟹HTTPS Server:</a><ul>
                        
                <li>
                    <a href="#%e5%ae%9e%e9%aa%8c%e8%a6%81%e6%b1%82" aria-label="实验要求">实验要求</a></li>
                <li>
                    <a href="#%e5%89%8d%e7%bd%ae%e7%9f%a5%e8%af%86" aria-label="前置知识">前置知识</a><ul>
                        
                <li>
                    <a href="#1-osi" aria-label="1. OSI">1. OSI</a></li>
                <li>
                    <a href="#2-%e4%bc%a0%e8%be%93%e5%b1%82transport-layer" aria-label="2. 传输层（Transport Layer）">2. 传输层（Transport Layer）</a></li>
                <li>
                    <a href="#3-rfc" aria-label="3. RFC">3. RFC</a></li>
                <li>
                    <a href="#4-tcp-socket" aria-label="4. TCP Socket">4. TCP Socket</a></li>
                <li>
                    <a href="#socket-%e7%bc%96%e7%a8%8b" aria-label="Socket 编程">Socket 编程</a><ul>
                        
                <li>
                    <a href="#%e7%ac%ac-1-%e6%ad%a5%e5%88%9b%e5%bb%ba-socket" aria-label="第 1 步：创建 Socket">第 1 步：创建 Socket</a></li>
                <li>
                    <a href="#%e7%ac%ac-2-%e6%ad%a5%e7%bb%91%e5%ae%9a-socket" aria-label="第 2 步：绑定 Socket">第 2 步：绑定 Socket</a></li>
                <li>
                    <a href="#%e7%ac%ac-34-%e6%ad%a5%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%9b%91%e5%90%ac%e7%ab%af%e5%8f%a3%e7%ad%89%e5%be%85%e8%bf%9e%e6%8e%a5" aria-label="第 3/4 步：服务器监听端口等待连接">第 3/4 步：服务器监听端口等待连接</a></li>
                <li>
                    <a href="#%e7%ac%ac-56-%e6%ad%a5%e6%8e%a5%e6%94%b6%e5%8f%91%e9%80%81%e6%95%b0%e6%8d%ae" aria-label="第 5/6 步：接收/发送数据">第 5/6 步：接收/发送数据</a></li>
                <li>
                    <a href="#%e7%ac%ac-7-%e6%ad%a5%e5%85%b3%e9%97%ad-socket" aria-label="第 7 步：关闭 Socket">第 7 步：关闭 Socket</a></li>
                <li>
                    <a href="#tcp-socket-%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%ab%af%e5%ae%8c%e6%95%b4%e4%bb%a3%e7%a0%81" aria-label="TCP Socket 服务器端完整代码">TCP Socket 服务器端完整代码</a></li>
                <li>
                    <a href="#%e6%b5%8b%e8%af%95%e7%bb%93%e6%9e%9c" aria-label="测试结果">测试结果</a></li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a></li></ul>
                </li>
                <li>
                    <a href="#http-%e6%9c%8d%e5%8a%a1%e5%99%a8" aria-label="HTTP 服务器">HTTP 服务器</a></li>
                <li>
                    <a href="#http-client" aria-label="HTTP Client">HTTP Client</a></li>
                <li>
                    <a href="#http-methods" aria-label="HTTP Methods">HTTP Methods</a></li>
                <li>
                    <a href="#http-server" aria-label="HTTP Server">HTTP Server</a></li>
                <li>
                    <a href="#%e5%ae%a2%e6%88%b7%e7%ab%af%e8%af%b7%e6%b1%82%e7%bd%91%e9%a1%b5%e7%90%86%e8%ae%ba" aria-label="客户端请求网页（理论）">客户端请求网页（理论）</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5" aria-label="参考链接">参考链接</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="http-serverhttps-server">HTTP Server⟹HTTPS Server:<a hidden class="anchor" aria-hidden="true" href="#http-serverhttps-server">#</a></h1>
<h2 id="实验要求">实验要求<a hidden class="anchor" aria-hidden="true" href="#实验要求">#</a></h2>
<p>这是网络课的一个小作业，具体要求如下：</p>
<p><strong>使用 C 语言实现一个 HTTP 服务器</strong></p>
<ul>
<li>
<p>支持 HTTP Post/Get 方法，可以上传或下载文件</p>
</li>
<li>
<p>支持 HTTP 分块传输，支持 HTTP 持久连接和管道</p>
</li>
<li>
<p>使用 openssl 库，支持 HTTPS</p>
</li>
<li>
<p>使用 libevent 支持多路并发</p>
</li>
<li>
<p>提交：代码和实验报告，实现越完整越好，测试越充分越好</p>
</li>
</ul>
<h2 id="前置知识">前置知识<a hidden class="anchor" aria-hidden="true" href="#前置知识">#</a></h2>
<p>HTTP 无所不在，我们日常访问的网站都在 HTTP 服务器上运行。</p>
<p>现在更常见的是 HTTPS，从技术的角度上看，HTTPS 相比于 HTTP 来说具有更高的安全性。</p>
<p>如何构建 HTTP 服务器呢？这其实是非常简单的。在开始之前，需要先复习一下基本的网络知识。</p>
<h3 id="1-osi">1. OSI<a hidden class="anchor" aria-hidden="true" href="#1-osi">#</a></h3>
<p>首先，需要对 OSI 有一个基本的认识和了解。</p>
<p>OSI 全称为 Open Systems Interconnection。</p>
<blockquote>
<p>OSI 模型是一个概念模型，它对电信或计算系统的通信功能进行描述和标准化，而不考虑其基本的内部结构和技术。</p>
<p>它的目标是用标准协议实现不同通信系统的互操作性。该模型将通信系统划分为若干抽象层。该模型的最初版本定义了七个层。</p>
</blockquote>
<p><a href="https://medium.com/@int0x33/day-51-understanding-the-osi-model-f22d5f3df756">图片链接：OSI 七层模型</a></p>
<p><img loading="lazy" src="./20201107/2.jpg" alt=""  />
</p>
<p>为了实现 HTTP 服务器，需要关心的是第四层——传输层（Transport Layer）。</p>
<h3 id="2-传输层transport-layer">2. 传输层（Transport Layer）<a hidden class="anchor" aria-hidden="true" href="#2-传输层transport-layer">#</a></h3>
<blockquote>
<p>传输层主要负责确保数据可靠无误地从一个点传输到另一个点。例如，传输层确保数据以正确的顺序发送和接收。</p>
<p>传输层提供流控制和错误处理，并参与解决有关数据包的传输和接收问题。传输层协议的常见例子有传输控制协议（TCP）、用户数据报协议（UDP）和顺序包交换（SPX）。</p>
</blockquote>
<p>在传输层，主要使用 TCP 来实现 HTTP 服务器。虽然也可以使用 UDP 实现，但是并没有很多人这么做。</p>
<blockquote>
<p>HTTP 通信通常通过 TCP/IP 连接进行。默认端口是 TCP 80，但也可以使用其他端口。这并不排除 HTTP 在 Internet 上或其他网络上的任何其他协议之上实现。</p>
<p>HTTP 只预设了一个可靠的传输，任何提供这种保证的协议都可以使用，HTTP/1.1 请求和响应结构在有关协议的传输数据单元上的映射不在本规范的范围之内。</p>
<p>——RFC 2616</p>
</blockquote>
<p>所有著名的 HTTP 服务器如 Apache Tomcat、NginX 等都是在 TCP 之上实现的。所以，使用基于 TCP 的 HTTP 服务器是一个正确的选择。</p>
<h3 id="3-rfc">3. RFC<a hidden class="anchor" aria-hidden="true" href="#3-rfc">#</a></h3>
<p>RFC 是什么？</p>
<p>RFC 全称为 Request for Comments。</p>
<p>Request for Comments 文件是 Steve Crocker 在 1969 年发明的，用于帮助记录 ARPANET 发展的非官方笔记。此后，RFCs 成为互联网规范、通信协议、程序和事件的正式文件。</p>
<blockquote>
<ul>
<li>
<p>截至 2017 年 8 月，共有 8200 多个 RFC。</p>
</li>
<li>
<p>万维网上 RFCs 的官方来源是 RFC Editor。</p>
</li>
<li>
<p>一些标准化的RFC有。</p>
<ul>
<li>HTTP/1.1 → 最初是 RFC 2616，后来被 RFC 7230、RFC 7231、RFC 7232、RFC 7233、RFC 7234、RFC 7235 取代。所以，需要从 RFC 7230 到 RFC 7235 来实现 HTTP 的基本工作原理。</li>
<li>HTTP/2 → RFC 7540 和 RFC 7541</li>
<li>FTP → RFC959</li>
</ul>
</li>
<li>
<p>所以，如果要实现 HTTP 服务器，可以先阅读特定的 RFC，即 RFC 7230、RFC 7231、RFC 7232、RFC 7233、RFC 7234、RFC 7235。</p>
</li>
</ul>
</blockquote>
<h3 id="4-tcp-socket">4. TCP Socket<a hidden class="anchor" aria-hidden="true" href="#4-tcp-socket">#</a></h3>
<p>要实现 TCP，我们必须学习 TCP Socket 编程。</p>
<p>Socket 也叫做套接字。</p>
<blockquote>
<p>套接字是大多数流行的操作系统提供的让程序访问网络的机制，它允许不同网络机器上的应用程序（无关的进程）之间收发消息。它允许在不同网络机器上的应用程序（不相关的进程）之间发送和接收消息。</p>
<p>套接字机制是为了独立于任何特定类型的网络而创建的。</p>
<p>IP 是迄今为止最主要的网络，也是套接字最流行的用途。</p>
</blockquote>
<p>Socket 编程的几个重要步骤</p>
<ul>
<li>创建 Socket</li>
<li>绑定 Socket</li>
<li>服务器端等待连接</li>
<li>发送和接收消息</li>
<li>关闭 Socket</li>
</ul>
<p><img loading="lazy" src="./20201107/3.png" alt=""  />
</p>
<h3 id="socket-编程">Socket 编程<a hidden class="anchor" aria-hidden="true" href="#socket-编程">#</a></h3>
<p>实现一个基于 TCP 通信的服务器。</p>
<h4 id="第-1-步创建-socket">第 1 步：创建 Socket<a hidden class="anchor" aria-hidden="true" href="#第-1-步创建-socket">#</a></h4>
<p><code>socket</code> 函数：<code>man socket</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>NAME
</span></span><span style="display:flex;"><span>     socket -- create an endpoint <span style="color:#66d9ef">for</span> communication
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>SYNOPSIS
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">#include &lt;sys/socket.h&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>     int
</span></span><span style="display:flex;"><span>     socket<span style="color:#f92672">(</span>int domain, int type, int protocol<span style="color:#f92672">)</span>;
</span></span></code></pre></div><ul>
<li><code>domain</code>：域名或地址族通信域，套接字应在其中创建。一些地址族有 AF_INET(IP)、AF_INET6(IPv6)、AF_UNIX（本地通道，类似管道）、AF_ISO（ISO 协议）和 AF_NS（Xerox 网络系统协议)。</li>
<li><code>type</code>：服务类型。这要根据应用所需的属性来选择。SOCK_STREAM（TCP 字节流）、SOCK_DGRAM（数据报服务）、SOCK_RAW（直接 IP 服务）。</li>
<li><code>protocol</code>：对于 TCP/IP 套接字，要指定 IP 地址族为 AF_INET 和虚拟电路服务（SOCK_STREAM）。由于虚拟电路服务只有一种形式，所以没有协议的变化，所以最后一个参数 protocol 为零。</li>
</ul>
<p>示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 1. 创建 TCP Socket
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> sfd <span style="color:#f92672">=</span> socket(AF_INET, SOCK_STREAM, <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><h4 id="第-2-步绑定-socket">第 2 步：绑定 Socket<a hidden class="anchor" aria-hidden="true" href="#第-2-步绑定-socket">#</a></h4>
<p>创建套接字后，需要给套接字绑定（<code>bind</code>）一个网络传输地址。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bind</span>(<span style="color:#66d9ef">int</span> socket, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> sockaddr <span style="color:#f92672">*</span>address, socklen_t address_len);
</span></span></code></pre></div><ul>
<li>第一个参数 <code>socket</code> 是第 1 步所创建的 <code>sfd</code>。</li>
<li>第二个参数，<code>sockaddr </code> 是一个结构体数据，对于 IP 网络，使用的是 <code>sockaddr_in</code>，它在头netinet/in.h 中定义</li>
<li>第三个参数一半传入<code>sizeof(svr_addr)</code>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// #include &lt;netinet/in.h&gt;  // sockaddr_in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Socket address, internet style.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> sockaddr_in {
</span></span><span style="display:flex;"><span>	__uint8_t       sin_len;
</span></span><span style="display:flex;"><span>	sa_family_t     sin_family;
</span></span><span style="display:flex;"><span>	in_port_t       sin_port;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span>  in_addr sin_addr;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">char</span>            sin_zero[<span style="color:#ae81ff">8</span>];
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li><code>sin_family</code>：<code>socket</code> 使用的地址族。本次实现的 TCP ，它是 AF_INET。</li>
<li><code>sin_port</code>：端口号</li>
<li><code>sin_addr</code>：IP 地址，是一个 32 位的无符号整型</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> in_addr {
</span></span><span style="display:flex;"><span>	in_addr_t s_addr;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> __uint32_t      in_addr_t;      <span style="color:#75715e">/* base type for internet address */</span>
</span></span></code></pre></div><p>使用示例：（这里还涉及大端序和小端序的知识）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 2. bind() 绑定 IP 和端口号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> sockaddr_in svr_addr;    <span style="color:#75715e">//用于填写服务器的 IP 地址与端口号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>svr_addr.sin_family <span style="color:#f92672">=</span> AF_INET;  <span style="color:#75715e">//地址族
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>svr_addr.sin_port <span style="color:#f92672">=</span> htons(<span style="color:#ae81ff">8888</span>);  <span style="color:#75715e">//端口号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>svr_addr.sin_addr.s_addr <span style="color:#f92672">=</span> inet_addr(<span style="color:#e6db74">&#34;10.203.11.153&#34;</span>); <span style="color:#75715e">// IP 地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (bind(sfd, (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> sockaddr <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>svr_addr, <span style="color:#66d9ef">sizeof</span>(svr_addr)) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  perror(<span style="color:#e6db74">&#34;bind() error&#34;</span>); 
</span></span><span style="display:flex;"><span>  exit(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="第-34-步服务器监听端口等待连接">第 3/4 步：服务器监听端口等待连接<a hidden class="anchor" aria-hidden="true" href="#第-34-步服务器监听端口等待连接">#</a></h4>
<p>建立监听队列，等待连接。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/socket.h&gt; </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">listen</span>(<span style="color:#66d9ef">int</span> socket, <span style="color:#66d9ef">int</span> backlog);
</span></span></code></pre></div><p>第二个参数 <code>backlog</code> 定义了在拒绝连接之前可以排队等待的最大连接数。</p>
<p>使用示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 3. 建立监听队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (listen(sfd, <span style="color:#ae81ff">10</span>) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>  perror(<span style="color:#e6db74">&#34;listen()&#34;</span>);  <span style="color:#75715e">//输出出错原因
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  exit(EXIT_FAILURE);  <span style="color:#75715e">//退出应用程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><code>accept</code> 系统调用会抓取待处理连接队列中的第一个连接请求，并为该连接创建一个新的套接字。</p>
<p>原来为监听而设置的套接字只用于接受连接，不用于交换数据。默认情况下，套接字操作是同步的，或者说是阻塞的，accept 会阻塞，直到队列上有连接存在。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/socket.h&gt; </span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">accept</span>(<span style="color:#66d9ef">int</span> socket, <span style="color:#66d9ef">struct</span> sockaddr <span style="color:#f92672">*</span><span style="color:#66d9ef">restrict</span> address, socklen_t <span style="color:#f92672">*</span><span style="color:#66d9ef">restrict</span> address_len);
</span></span></code></pre></div><ul>
<li>第一个参数 <code>socket</code> 是设置用于接受监听连接的 socket。</li>
<li>第二个参数 <code>address</code> 是与进行连接的客户端的地址一起归档的地址结构。这样我们就可以在需要的时候检查连接 socket 的地址和端口号。</li>
<li>第三个参数是填入地址结构的长度。</li>
</ul>
<p>使用示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 4. 服务器接收客户端的连接请求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 记录客户端的地址信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> sockaddr_in client_addr;
</span></span><span style="display:flex;"><span>socklen_t len <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(client_addr);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> cfd <span style="color:#f92672">=</span> accept(sfd, (<span style="color:#66d9ef">struct</span> sockaddr <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>client_addr, <span style="color:#f92672">&amp;</span>len);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (cfd <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>  perror(<span style="color:#e6db74">&#34;accept() error!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  exit(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="第-56-步接收发送数据">第 5/6 步：接收/发送数据<a hidden class="anchor" aria-hidden="true" href="#第-56-步接收发送数据">#</a></h4>
<p>现在终于把客户端（当从网页浏览器访问服务器的 IP 地址时）和服务器之间的套接字连接起来了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 第4步连接成功，打印出客户端的 IP 和端口号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>printf(<span style="color:#e6db74">&#34;client ip: %s, port: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, inet_ntoa(client_addr.sin_addr), htons(client_addr.sin_port));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 5. 接收客户端的数据 server &lt;------ client
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> recv_buffer[<span style="color:#ae81ff">1024</span>] <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#39;\0&#39;</span>};
</span></span><span style="display:flex;"><span>ssize_t rbytes <span style="color:#f92672">=</span> recv(cfd, recv_buffer, <span style="color:#66d9ef">sizeof</span>(recv_buffer), <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (rbytes <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>  perror(<span style="color:#e6db74">&#34;recv() error!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  exit(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>printf(<span style="color:#e6db74">&#34;recv: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, recv_buffer);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 6. 向客户端发送数据： server ------&gt; client
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> send_buffer[<span style="color:#ae81ff">1024</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello, Client. Your IP is &#34;</span>;
</span></span><span style="display:flex;"><span>strcat(send_buffer, inet_ntoa(client_addr.sin_addr));
</span></span><span style="display:flex;"><span>size_t sbytes <span style="color:#f92672">=</span> send(cfd, send_buffer, strlen(send_buffer)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (sbytes <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>  perror(<span style="color:#e6db74">&#34;send() error!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  exit(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="第-7-步关闭-socket">第 7 步：关闭 Socket<a hidden class="anchor" aria-hidden="true" href="#第-7-步关闭-socket">#</a></h4>
<p>最后，别忘了关闭 Socket。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 关闭连接
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>close(cfd);
</span></span></code></pre></div><h4 id="tcp-socket-服务器端完整代码">TCP Socket 服务器端完整代码<a hidden class="anchor" aria-hidden="true" href="#tcp-socket-服务器端完整代码">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// HTTP_server.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;       // exit</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;arpa/inet.h&gt;    // inet_ntoa</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;netinet/in.h&gt;   // sockaddr_in</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;       // strlen</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;       // close function</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 1. 创建 Socket 套接字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> sfd <span style="color:#f92672">=</span> socket(AF_INET, SOCK_STREAM, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (sfd <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>    perror(<span style="color:#e6db74">&#34;socket() error!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    exit(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 2. bind() 绑定 IP 和端口号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> sockaddr_in svr_addr;  <span style="color:#75715e">//用于填写服务器的ip地址与端口号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  svr_addr.sin_family <span style="color:#f92672">=</span> AF_INET;  <span style="color:#75715e">//地址族
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  svr_addr.sin_port <span style="color:#f92672">=</span> htons(<span style="color:#ae81ff">8888</span>);  <span style="color:#75715e">//端口号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  svr_addr.sin_addr.s_addr <span style="color:#f92672">=</span> inet_addr(<span style="color:#e6db74">&#34;10.203.11.153&#34;</span>);  <span style="color:#75715e">//ip地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (bind(sfd, (<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> sockaddr <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>svr_addr, <span style="color:#66d9ef">sizeof</span>(svr_addr)) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    perror(<span style="color:#e6db74">&#34;bind()&#34;</span>);
</span></span><span style="display:flex;"><span>    exit(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 3. 建立监听队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (listen(sfd, <span style="color:#ae81ff">10</span>) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    perror(<span style="color:#e6db74">&#34;listen()&#34;</span>);
</span></span><span style="display:flex;"><span>    exit(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 4. 服务器接收客户端的连接请求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 记录客户端的地址信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> sockaddr_in client_addr;
</span></span><span style="display:flex;"><span>  socklen_t len <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(client_addr);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> cfd <span style="color:#f92672">=</span> accept(sfd, (<span style="color:#66d9ef">struct</span> sockaddr <span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>client_addr, <span style="color:#f92672">&amp;</span>len);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (cfd <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>    perror(<span style="color:#e6db74">&#34;accept() error!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    exit(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 连接成功，打印出客户端的 IP 和端口号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  printf(<span style="color:#e6db74">&#34;client ip: %s, port: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, inet_ntoa(client_addr.sin_addr), htons(client_addr.sin_port));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 5. 接收客户端的数据 server &lt;------ client
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">char</span> recv_buffer[<span style="color:#ae81ff">1024</span>] <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#39;\0&#39;</span>};
</span></span><span style="display:flex;"><span>  ssize_t rbytes <span style="color:#f92672">=</span> recv(cfd, recv_buffer, <span style="color:#66d9ef">sizeof</span>(recv_buffer), <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (rbytes <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>    perror(<span style="color:#e6db74">&#34;recv() error!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    exit(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  printf(<span style="color:#e6db74">&#34;recv: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, recv_buffer);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 6. 向客户端发送数据： server ------&gt; client
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">char</span> send_buffer[<span style="color:#ae81ff">1024</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello, Client. Your IP is &#34;</span>;
</span></span><span style="display:flex;"><span>  strcat(send_buffer, inet_ntoa(client_addr.sin_addr));
</span></span><span style="display:flex;"><span>  size_t sbytes <span style="color:#f92672">=</span> send(cfd, send_buffer, strlen(send_buffer)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (sbytes <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>    perror(<span style="color:#e6db74">&#34;send() error!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    exit(EXIT_FAILURE);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 7. 关闭连接
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  close(cfd);
</span></span><span style="display:flex;"><span>  close(sfd);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>客户端的写法是：<code>socket() - connect() - send() - recv() - close()</code>。</p>
<p>这里我偷懒了，直接使用一个简单的「网络调试助手」来替代客户端。</p>
<h4 id="测试结果">测试结果<a hidden class="anchor" aria-hidden="true" href="#测试结果">#</a></h4>
<p>1、服务器 IP 和监听的端口号</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>svr_addr.sin_port <span style="color:#f92672">=</span> htons(<span style="color:#ae81ff">8888</span>);  <span style="color:#75715e">//端口号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>svr_addr.sin_addr.s_addr <span style="color:#f92672">=</span> inet_addr(<span style="color:#e6db74">&#34;10.203.11.153&#34;</span>);  <span style="color:#75715e">//IP 地址
</span></span></span></code></pre></div><p>2、启动服务器（配置 IP 地址为自己电脑的）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>➜  Build-a-simple-HTTP-server gcc HTTP_server.c
</span></span><span style="display:flex;"><span>➜  Build-a-simple-HTTP-server ./a.out
</span></span></code></pre></div><p>3、客户端连接服务器，发送 “Hello, Server! This is Client.”</p>
<p><img loading="lazy" src="./20201107/4.png" alt=""  />
</p>
<p>4、观察结果：服务器端接收到了客户端发送的消息；客户端接收区接收到了服务器的消息。</p>
<p><img loading="lazy" src="./20201107/5.png" alt=""  />
</p>
<h4 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h4>
<p>程序运行能够在应用程序之间进行通信。这意味着以上实现的 TCP 实现工作正常。</p>
<p>至此已经完成了最基本的编码部分。</p>
<p>现在继续进行 HTTP 服务器的实现。</p>
<h3 id="http-服务器">HTTP 服务器<a hidden class="anchor" aria-hidden="true" href="#http-服务器">#</a></h3>
<p>首先看看服务器和 Web 浏览器之间的交互。</p>
<p><img loading="lazy" src="./20201107/6.png" alt=""  />
</p>
<p>再把 HTTP 部分放大，进行更加细致的了解。</p>
<p><img loading="lazy" src="./20201107/7.png" alt=""  />
</p>
<ul>
<li>HTTP Client（即 Web 浏览器）向 HTTP Server 发送 HTTP 请求。</li>
<li>服务器处理收到的请求，并向 HTTP Client 发送 HTTP 响应。</li>
</ul>
<p>现在，细致的客户端-服务器，以及它们发送和接收的内容。</p>
<h3 id="http-client">HTTP Client<a hidden class="anchor" aria-hidden="true" href="#http-client">#</a></h3>
<p>HTTP 客户端（Web浏览器）是请求的发起者。</p>
<p>向浏览器中输入一个连接：</p>
<pre tabindex="0"><code>http://www.example.com
</code></pre><p>为了显示页面，浏览器从 Web 服务器 80 端口获取文件 index.html（默认网页）。发出的请求如下：</p>
<p><img loading="lazy" src="./20201107/8.png" alt=""  />
</p>
<p>现在，<code>HTTP_server.c </code> 先不做任何修改，运行程序，启动服务器。直接在浏览器中输入 <code>l0.203.11.153:8888</code> ，看看会发生什么。</p>
<p><img loading="lazy" src="./20201107/9.png" alt=""  />
</p>
<p>该网页无法正常运行。</p>
<p>在看看服务器端输出了什么：</p>
<p><img loading="lazy" src="./20201107/11.png" alt=""  />
</p>
<p>非常有意思，这值得好好看一看。第一行：</p>
<pre tabindex="0"><code>client ip: 10.203.11.153, port: 54813
</code></pre><p>这是我们的服务器端自己 <code>printf</code> 的，第二行的 &ldquo;recv:&rdquo; 也是，不算。所有服务器端接收到的内容应该是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>GET / HTTP/1.1
</span></span><span style="display:flex;"><span>Host: 10.203.11.153:8888
</span></span><span style="display:flex;"><span>Connection: keep-alive
</span></span><span style="display:flex;"><span>Upgrade-Insecure-Requests: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>User-Agent: Mozilla/5.0 <span style="color:#f92672">(</span>Macintosh; Intel Mac OS X 10_15_6<span style="color:#f92672">)</span> AppleWebKit/537.36 <span style="color:#f92672">(</span>KHTML, like Gecko<span style="color:#f92672">)</span> Chrome/78.0.3904.108 Safari/537.36
</span></span><span style="display:flex;"><span>Accept: text/html,application/xhtml+xml,application/xml;q<span style="color:#f92672">=</span>0.9,image/webp,image/apng,*/*;q<span style="color:#f92672">=</span>0.8,application/signed-exchange;v<span style="color:#f92672">=</span>b3
</span></span><span style="display:flex;"><span>Accept-Encoding: gzip, deflate
</span></span><span style="display:flex;"><span>Accept-Language: en-US,en;q<span style="color:#f92672">=</span>0.9,zh-CN;q<span style="color:#f92672">=</span>0.8,zh;q<span style="color:#f92672">=</span>0.7,und;q<span style="color:#f92672">=</span>0.6,es;q<span style="color:#f92672">=</span>0.5,fr;q<span style="color:#f92672">=</span>0.4,zh-TW;q<span style="color:#f92672">=</span>0.3,ja;q<span style="color:#f92672">=</span>0.2
</span></span></code></pre></div><p>按理说服务器接收到客户端的连接后，应该会向客户端发送 &ldquo;Hello, Clinet, &hellip;.&quot;，但是网页却无法正常运行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 6. 向客户端发送数据： server ------&gt; client
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> send_buffer[<span style="color:#ae81ff">1024</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello, Client. Your IP is &#34;</span>;
</span></span><span style="display:flex;"><span>strcat(send_buffer, inet_ntoa(client_addr.sin_addr));
</span></span><span style="display:flex;"><span>size_t sbytes <span style="color:#f92672">=</span> send(cfd, send_buffer, strlen(send_buffer)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><p>要解决这个问题，就要了解一下 HTTP 的知识了。</p>
<h3 id="http-methods">HTTP Methods<a hidden class="anchor" aria-hidden="true" href="#http-methods">#</a></h3>
<p>GET 是 HTTP 默认使用的方法，如上面终端中，Server 接收到的信息，第一行就是一个 GET。</p>
<p>常用的 HTTP Methods：</p>
<ul>
<li>GET：获取一个 URL。</li>
<li>HEAD：获取一个 URL 的信息。</li>
<li>PUT：存储到一个 URL。</li>
<li>POST：将表单数据发送至一个 URL 并获得响应。</li>
<li>DELETE：删除一个 URL GET 和 POST（表单）是常用的。</li>
</ul>
<h3 id="http-server">HTTP Server<a hidden class="anchor" aria-hidden="true" href="#http-server">#</a></h3>
<p>客户端发送了一些头信息（GET &hellip;），希望服务器做出响应的响应。</p>
<p>但我们自己实现的 HTTP_server 只发送了一个问候信息，这缺少一些必要的头信息，这就是问题的所在。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 6. 向客户端发送数据： server ------&gt; client
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> send_buffer[<span style="color:#ae81ff">1024</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello, Client. Your IP is &#34;</span>;
</span></span><span style="display:flex;"><span>strcat(send_buffer, inet_ntoa(client_addr.sin_addr));
</span></span><span style="display:flex;"><span>size_t sbytes <span style="color:#f92672">=</span> send(cfd, send_buffer, strlen(send_buffer)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><p>浏览器希望得到的是一个与请求相同格式的数据。</p>
<p>HTTP 不过是遵循 RFC 文件中指定的一些规则，它的实现与语言无关。</p>
<p>如下是网络浏览器所期待的 HTTP 响应格式的例子。显示的头信息只是一个例子。HTTP 中还有很多头信息存在，具体可以看 HTTP RFCs → RFC 7230, RFC 7231, RFC 7232, RFC 7233, RFC 7234, RFC 7235。</p>
<p><img loading="lazy" src="./20201107/12.png" alt=""  />
</p>
<p>如果想从服务器发送 Hello：</p>
<ul>
<li>
<p>首先需要构造 Header，</p>
</li>
<li>
<p>然后插入一个空行</p>
</li>
<li>
<p>之后我们就可以发送消息/数据。</p>
<p>现在，开始构造一个最小的 HTTP Header 来使 HTTP 服务器正常工作。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">char</span> send_buffer[<span style="color:#ae81ff">1024</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;HTTP/1.1 200 OK</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Content-Type: text/plain</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Content-Length: 39</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">Hello, Client. Your IP is &#34;</span>;
</span></span><span style="display:flex;"><span>strcat(send_buffer, inet_ntoa(client_addr.sin_addr));
</span></span></code></pre></div><p>如上的 3 个头信息是最低要求。</p>
<ul>
<li>HTTP/1.1 200 OK ：使用的 HTTP 版本号、状态码和状态信息。</li>
<li>Content-Type: text/plain ：服务器发送的是纯文本。Content-Type 还有其他的格式。</li>
<li>Content-Length: 39 ：服务器向客户端发送 39 字节。网络浏览器只读取我们在这里提到的数量。</li>
<li>最后一部分是 Body。在这里发送自定义的数据。
<ul>
<li>首先，需要在 Body 中计算出发送的字节数，与 Content-Length 相同。</li>
</ul>
</li>
</ul>
<p><code>&quot;Hello, Client. Your IP is 10.203.11.153&quot; </code>的长度刚好等于 39 字节。</p>
<p>客户端将会接收到：</p>
<pre tabindex="0"><code>HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 39

Hello, Client. Your IP is 10.203.11.153
</code></pre><p>浏览器访问 IP:8888，可以看到工作正常。</p>
<p><img loading="lazy" src="./20201107/13.png" alt=""  />
</p>
<blockquote>
<p>关于状态码和状态信息：</p>
<ul>
<li>
<p>状态码是服务器根据客户向服务器提出的请求而发出的。它包括 IETF Request for Comments (RFCs)、其他规范中的代码，以及超文本传输协议（HTTP）的一些常见应用中使用的附加代码。</p>
</li>
<li>
<p>状态码的第一个数字指定了五种标准响应类别中的一种。所显示的消息短语是典型的，但可以提供任何人类可读的替代方案。除非另有说明，否则状态码是 HTTP/1.1 标准（RFC 7231）的一部分。</p>
</li>
<li>
<p>所以，如果服务器找不到客户端要求的文件，那么就发送适当的状态码。</p>
</li>
<li>
<p>如果客户端没有权限查看文件，那么就发送相应的状态码。</p>
</li>
<li>
<p>常见的<a href="https://httpstatuses.com/">状态码</a>：</p>
<ul>
<li>
<p><a href="https://httpstatuses.com/200">200 OK</a></p>
</li>
<li>
<p><a href="https://httpstatuses.com/403">403 Forbidden</a></p>
</li>
<li>
<p><a href="https://httpstatuses.com/404">404 Not Found</a></p>
</li>
<li>
<p><a href="https://httpstatuses.com/502">502 Bad Gateway</a></p>
</li>
</ul>
</li>
<li>
<p>Informational responses (<code>100</code>–<code>199</code>),</p>
</li>
<li>
<p>Successful responses (<code>200</code>–<code>299</code>),</p>
</li>
<li>
<p>Redirects (<code>300</code>–<code>399</code>),</p>
</li>
<li>
<p>Client errors (<code>400</code>–<code>499</code>),</p>
</li>
<li>
<p>and Server errors (<code>500</code>–<code>599</code>).</p>
</li>
</ul>
</blockquote>
<p>现在，HTTP 已经正常工作了。虽然它非常非常的简陋。</p>
<h3 id="客户端请求网页理论">客户端请求网页（理论）<a hidden class="anchor" aria-hidden="true" href="#客户端请求网页理论">#</a></h3>
<p>到现在为止，已经实现一个能向浏览器客户端发送一个字符串的 HTTP 服务器。</p>
<p>现在，来看看如何发送一个文件、图片等信息。假设在地址栏中输入：</p>
<pre tabindex="0"><code>IP:8888/info.html
</code></pre><p>在服务器终端，将会得到如下请求。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>GET /info.html HTTP/1.1
</span></span><span style="display:flex;"><span>Host: 10.203.11.153:8888
</span></span><span style="display:flex;"><span>Connection: keep-alive
</span></span><span style="display:flex;"><span>Upgrade-Insecure-Requests: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>User-Agent: Mozilla/5.0 <span style="color:#f92672">(</span>Macintosh; Intel Mac OS X 10_15_6<span style="color:#f92672">)</span> AppleWebKit/537.36 <span style="color:#f92672">(</span>KHTML, like Gecko<span style="color:#f92672">)</span> Chrome/78.0.3904.108 Safari/537.36
</span></span><span style="display:flex;"><span>Accept: text/html,application/xhtml+xml,application/xml;q<span style="color:#f92672">=</span>0.9,image/webp,image/apng,*/*;q<span style="color:#f92672">=</span>0.8,application/signed-exchange;v<span style="color:#f92672">=</span>b3
</span></span><span style="display:flex;"><span>Accept-Encoding: gzip, deflate
</span></span><span style="display:flex;"><span>Accept-Language: en-US,en;q<span style="color:#f92672">=</span>0.9,zh-CN;q<span style="color:#f92672">=</span>0.8,zh;q<span style="color:#f92672">=</span>0.7,und;q<span style="color:#f92672">=</span>0.6,es;q<span style="color:#f92672">=</span>0.5,fr;q<span style="color:#f92672">=</span>0.4,zh-TW;q<span style="color:#f92672">=</span>0.3,ja;q<span style="color:#f92672">=</span>0.2
</span></span></code></pre></div><p>看一看请求头中的第一行。</p>
<pre tabindex="0"><code>GET /info.html HTTP/1.1
</code></pre><p>所以，服务器只需要在当前目录下搜索 info.html 文件。</p>
<p>当然还有很多情况需要服务器考虑，例如：</p>
<ul>
<li>文件（网页）是存在的</li>
<li>文件（网页）不存在</li>
<li>客户端没有访问文件（网页）的权限。</li>
<li>&hellip;..</li>
</ul>
<p>服务器端需要做的是：</p>
<ul>
<li>选择合适的状态码；</li>
<li>如果文件是存在的，并且客户端有权限访问它，选择合适的 Content-Type；</li>
<li>然后打开文件，将数据读到一个变量中。统计从文件中读取的字节数；</li>
<li>设置 Content-Length；</li>
<li>构造 Response Header；</li>
<li>在 Response Header 的末尾添加一个新行，并将从文件中读取的数据追加到其中；</li>
<li>发送给客户端。</li>
</ul>
<h2 id="参考链接">参考链接<a hidden class="anchor" aria-hidden="true" href="#参考链接">#</a></h2>
<ul>
<li><a href="https://medium.com/from-the-scratch/http-server-what-do-you-need-to-know-to-build-a-simple-http-server-from-scratch-d1ef8945e4fa">HTTP Server: Everything you need to know to Build a simple HTTP server from scratch</a></li>
<li><a href="https://httpstatuses.com/">HTTP Status Codes</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://landodo.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li>
      <li><a href="http://landodo.github.io/tags/http/">HTTP</a></li>
      <li><a href="http://landodo.github.io/tags/%E9%9D%A2%E8%AF%95/">面试</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://landodo.github.io/posts/20201215-network-in-network/">
    <span class="title">« Prev Page</span>
    <br>
    <span>Network In Network</span>
  </a>
  <a class="next" href="http://landodo.github.io/posts/20201106-prim-kruskal/">
    <span class="title">Next Page »</span>
    <br>
    <span>Prim 算法&amp;Kruskal 算法求最小生成树</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>Landon</span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
